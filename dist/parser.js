'use strict';

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _offside_ops = require('./offside_ops');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const tt = babylon.tokTypes;

var _g_offsidePluginOpts;

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  const tgt_patch = tt.braceL;
  const fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = (0, _offside_ops.parseOffsideIndexMap)(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      const offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

const tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

const tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

pp.isForAwait = function (keywordType, type, val) {
  return tt._for === keywordType && tt.name === type && 'await' === val;
};

const rx_offside_op = /(\S+)[ \t]*(\r\n|\r|\n)?/;

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  const recentKeyword = state.offsideRecentKeyword;
  const inForAwait = recentKeyword ? this.isForAwait(recentKeyword, type, val) : null;
  state.offsideRecentKeyword = null;

  if (tt_offside_keyword_with_args.has(type) || inForAwait) {
    const isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    state.offsideRecentKeyword = inForAwait ? tt._for : type;
    const lookahead = this.lookahead();

    if (tt_offside_keyword_lookahead_skip.has(lookahead.type)) {} else if (this.isForAwait(type, lookahead.type, lookahead.value)) {} else {
      state.offsideNextOp = _offside_ops.at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const m_op = rx_offside_op.exec(this.input.slice(pos0));
    const str_op = m_op[1];
    const lineEndsWithOp = !!m_op[2];

    let op = _offside_ops.at_offside[str_op];
    if (op) {
      if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(recentKeyword)) {
        op = _offside_ops.at_offside.keyword_args;
      } else if (lineEndsWithOp && op.nestInner) {
        // all offside operators at the end of a line implicitly don't nestInner
        op = { __proto__: op, nestInner: false };
      }

      this.finishOffsideOp(op, op.extraChars);

      if (op.nestOp) {
        state.offsideNextOp = _offside_ops.at_offside[op.nestOp];
      }
      return;
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideIndent = function (line0, outerIndent, innerIndent) {
  const offside_lines = this.offside_lines;

  if (null == innerIndent) {
    const innerLine = offside_lines[line0 + 1];
    innerIndent = innerLine ? innerLine.indent : '';
  }

  let line = line0 + 1,
      last = offside_lines[line0];
  while (line < offside_lines.length) {
    const cur = offside_lines[line];
    if (cur.content && outerIndent >= cur.indent) {
      line--; // backup to previous line
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  return { line, last, innerIndent };
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  const line0 = this.state.curLine;
  const first = this.offside_lines[line0];

  let indent, keywordNestedIndent;
  if (recentKeywordTop) {
    indent = recentKeywordTop.first.indent;
  } else if (op.nestInner && stackTop && line0 === stackTop.first.line) {
    indent = stackTop.innerIndent;
  } else if (op.inKeywordArg) {
    indent = first.indent;
    const indent_block = this.offsideIndent(line0, indent);
    const indent_keyword = this.offsideIndent(line0, indent_block.innerIndent);
    if (indent_keyword.innerIndent > indent_block.innerIndent) {
      // autodetect keyword argument using '@' for function calls
      indent = indent_block.innerIndent;
      keywordNestedIndent = indent_keyword.innerIndent;
    }
  } else {
    indent = first.indent;
  }

  let { last, innerIndent } = this.offsideIndent(line0, indent, keywordNestedIndent);

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  if (stackTop && stackTop.last.posLastContent < last.posLastContent) {
    // Fixup enclosing scopes. Happens in situations like: `server.on @ wraper @ (...args) => ::`
    const stack = this.state.offside;
    for (let idx = stack.length - 1; idx > 0; idx--) {
      let tip = stack[idx];
      if (tip.last.posLastContent >= last.posLastContent) {
        break;
      }
      tip.last = last;
    }
  }

  return { op, innerIndent, first, last };
};

pp.finishOffsideOp = function (op, extraChars) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      // We're at the end of an offside keyword block; restore enclosing ()
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (extraChars) {
    this.state.pos += extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  const blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  const stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvcGFyc2VyLmpzIl0sIm5hbWVzIjpbImJhYnlsb24iLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwiX3BvcyIsInBvcyIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInNldCIsIm9mZlBvcyIsIm9mZnNpZGVQb3MiLCJ0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzIiwiU2V0IiwiX2lmIiwiX3doaWxlIiwiX2ZvciIsIl9jYXRjaCIsIl9zd2l0Y2giLCJ0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAiLCJwYXJlbkwiLCJjb2xvbiIsImNvbW1hIiwiZG90IiwiaXNGb3JBd2FpdCIsImtleXdvcmRUeXBlIiwidHlwZSIsInZhbCIsIm5hbWUiLCJyeF9vZmZzaWRlX29wIiwiX2Jhc2VfZmluaXNoVG9rZW4iLCJmaW5pc2hUb2tlbiIsInJlY2VudEtleXdvcmQiLCJvZmZzaWRlUmVjZW50S2V5d29yZCIsImluRm9yQXdhaXQiLCJoYXMiLCJpc0tleXdvcmRBbGxvd2VkIiwiaXNMb29rYWhlYWQiLCJsb29rYWhlYWQiLCJ2YWx1ZSIsImtleXdvcmRfYXJncyIsImF0IiwiZG91YmxlQ29sb24iLCJwb3MwIiwic3RhcnQiLCJwb3MxIiwibV9vcCIsImV4ZWMiLCJzbGljZSIsInN0cl9vcCIsImxpbmVFbmRzV2l0aE9wIiwib3AiLCJrZXl3b3JkQmxvY2siLCJuZXN0SW5uZXIiLCJfX3Byb3RvX18iLCJmaW5pc2hPZmZzaWRlT3AiLCJleHRyYUNoYXJzIiwibmVzdE9wIiwiZW9mIiwibGVuZ3RoIiwicG9wT2Zmc2lkZSIsIm9mZnNpZGVJbmRlbnQiLCJsaW5lMCIsIm91dGVySW5kZW50IiwiaW5uZXJJbmRlbnQiLCJpbm5lckxpbmUiLCJpbmRlbnQiLCJsaW5lIiwibGFzdCIsImN1ciIsImNvbnRlbnQiLCJvZmZzaWRlQmxvY2siLCJzdGFja1RvcCIsInJlY2VudEtleXdvcmRUb3AiLCJjdXJMaW5lIiwiZmlyc3QiLCJrZXl3b3JkTmVzdGVkSW5kZW50IiwiaW5LZXl3b3JkQXJnIiwiaW5kZW50X2Jsb2NrIiwiaW5kZW50X2tleXdvcmQiLCJwb3NMYXN0Q29udGVudCIsInN0YWNrIiwiaWR4IiwidGlwIiwiY29kZUJsb2NrIiwib2Zmc2lkZVJlY2VudFRvcCIsInRva2VuUHJlIiwiYmxrIiwicHVzaCIsIl9iYXNlX3NraXBTcGFjZSIsInNraXBTcGFjZSIsImVyciIsIl9iYXNlX3JlYWRUb2tlbiIsInJlYWRUb2tlbiIsImNvZGUiLCJwb3AiLCJ0b2tlblBvc3QiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0lBQVlBLE87O0FBR1o7Ozs7QUFGQSxNQUFNQyxLQUFLRCxRQUFRRSxRQUFuQjs7QUFJQSxJQUFJQyxvQkFBSjs7QUFFQSxNQUFNQyxxQkFBcUJKLFFBQVFLLEtBQW5DO0FBQ0FMLFFBQVFLLEtBQVIsR0FBZ0IsQ0FBQ0MsS0FBRCxFQUFRQyxPQUFSLEtBQW9CO0FBQ2xDSix5QkFBdUJJLFVBQVVBLFFBQVFDLGlCQUFsQixHQUFzQ0MsU0FBN0Q7QUFDQSxTQUFPTCxtQkFBbUJFLEtBQW5CLEVBQTBCQyxPQUExQixDQUFQO0FBQXlDLENBRjNDOztBQUlBLE1BQU1H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RzBFLFVBQUgsR0FBZ0IsWUFBVztBQUN6QixRQUFNcUIsUUFBUSxLQUFLakYsS0FBTCxDQUFXQyxPQUF6QjtBQUNBLFFBQU11RSxXQUFXLEtBQUtuQyxXQUFMLEdBQ2I0QyxNQUFNQSxNQUFNdEIsTUFBTixHQUFhLENBQW5CLENBRGEsR0FFYnNCLE1BQU1jLEdBQU4sRUFGSjtBQUdBLE9BQUsvRixLQUFMLENBQVdXLFVBQVgsR0FBd0IsQ0FBQyxDQUF6Qjs7QUFFQSxPQUFLbUIsaUJBQUwsQ0FBdUIwQyxTQUFTckIsRUFBVCxDQUFZNkMsU0FBbkM7QUFDQSxTQUFPeEIsUUFBUDtBQUFlLENBUmpCIiwiZmlsZSI6InBhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGJhYnlsb24gZnJvbSAnYmFieWxvbidcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG5pbXBvcnQge2F0X29mZnNpZGUsIHBhcnNlT2Zmc2lkZUluZGV4TWFwfSBmcm9tICcuL29mZnNpZGVfb3BzJ1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcblxuY29uc3QgX2Jhc2VfbW9kdWxlX3BhcnNlID0gYmFieWxvbi5wYXJzZVxuYmFieWxvbi5wYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gOjpcbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBvcHRpb25zID8gb3B0aW9ucy5vZmZzaWRlUGx1Z2luT3B0cyA6IHVuZGVmaW5lZFxuICByZXR1cm4gX2Jhc2VfbW9kdWxlX3BhcnNlKGlucHV0LCBvcHRpb25zKVxuXG5jb25zdCBQYXJzZXIgPSBob29rQmFieWxvbigpXG5jb25zdCBiYXNlUHJvdG8gPSBQYXJzZXIucHJvdG90eXBlXG5jb25zdCBwcCA9IFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90bylcblxuZnVuY3Rpb24gaG9va0JhYnlsb24oKSA6OlxuICAvLyBhYnVzZSBCYWJ5bG9uIHRva2VuIHVwZGF0ZUNvbnRleHQgY2FsbGJhY2sgZXh0cmFjdFxuICAvLyB0aGUgcmVmZXJlbmNlIHRvIFBhcnNlclxuXG4gIGxldCBQYXJzZXJcbiAgY29uc3QgdGd0X3BhdGNoID0gdHQuYnJhY2VMXG4gIGNvbnN0IGZuX3VwZGF0ZUNvbnRleHQgPSB0Z3RfcGF0Y2gudXBkYXRlQ29udGV4dFxuICB0Z3RfcGF0Y2gudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkgOjpcbiAgICB0Z3RfcGF0Y2gudXBkYXRlQ29udGV4dCA9IGZuX3VwZGF0ZUNvbnRleHRcbiAgICBQYXJzZXIgPSB0aGlzLmNvbnN0cnVjdG9yXG5cbiAgYmFieWxvbi5wYXJzZSgne30nKVxuICBpZiAhIFBhcnNlciA6OlxuICAgIHRocm93IG5ldyBFcnJvciBAIFwiRmFpbGVkIHRvIGhvb2sgQmFieWxvbiBQYXJzZXJcIlxuICByZXR1cm4gUGFyc2VyXG5cblxucHAuX2Jhc2VfcGFyc2UgPSBiYXNlUHJvdG8ucGFyc2VcbnBwLnBhcnNlID0gZnVuY3Rpb24oKSA6OlxuICB0aGlzLmluaXRPZmZzaWRlKClcbiAgcmV0dXJuIHRoaXMuX2Jhc2VfcGFyc2UoKVxuXG5cbmNsYXNzIE9mZnNpZGVCcmVha291dCBleHRlbmRzIEVycm9yIHt9XG5jb25zdCBvZmZzaWRlQnJlYWtvdXQgPSBuZXcgT2Zmc2lkZUJyZWFrb3V0KClcblxucHAuaW5pdE9mZnNpZGUgPSBmdW5jdGlvbigpIDo6XG4gIHRoaXMuc3RhdGUub2Zmc2lkZSA9IFtdXG4gIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG51bGxcbiAgdGhpcy5vZmZzaWRlX2xpbmVzID0gcGFyc2VPZmZzaWRlSW5kZXhNYXAodGhpcy5pbnB1dClcbiAgdGhpcy5vZmZzaWRlUGx1Z2luT3B0cyA9IF9nX29mZnNpZGVQbHVnaW5PcHRzIHx8IHt9XG4gIF9nX29mZnNpZGVQbHVnaW5PcHRzID0gbnVsbFxuXG4gIHRoaXMuc3RhdGUuX3BvcyA9IHRoaXMuc3RhdGUucG9zXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBAIHRoaXMuc3RhdGUsICdwb3MnLFxuICAgIEB7fSBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAsIGdldCgpIDo6IHJldHVybiB0aGlzLl9wb3NcbiAgICAgICwgc2V0KHBvcykgOjpcbiAgICAgICAgICAvLyBpbnRlcnJ1cHQgc2tpcFNwYWNlIGFsZ29yaXRobSB3aGVuIHdlIGhpdCBvdXIgcG9zaXRpb24gJ2JyZWFrcG9pbnQnXG4gICAgICAgICAgY29uc3Qgb2ZmUG9zID0gdGhpcy5vZmZzaWRlUG9zXG4gICAgICAgICAgaWYgb2ZmUG9zPj0wICYmIChwb3MgPiBvZmZQb3MpIDo6XG4gICAgICAgICAgICB0aHJvdyBvZmZzaWRlQnJlYWtvdXRcblxuICAgICAgICAgIHRoaXMuX3BvcyA9IHBvc1xuXG5cbmNvbnN0IHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MgPSBuZXcgU2V0IEAjXG4gICAgICB0dC5faWYsIHR0Ll93aGlsZSwgdHQuX2ZvclxuICAgICwgdHQuX2NhdGNoLCB0dC5fc3dpdGNoXG5cbmNvbnN0IHR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCA9IG5ldyBTZXQgQCNcbiAgICAgIHR0LnBhcmVuTCwgdHQuY29sb24sIHR0LmNvbW1hLCB0dC5kb3RcblxucHAuaXNGb3JBd2FpdCA9IGZ1bmN0aW9uIChrZXl3b3JkVHlwZSwgdHlwZSwgdmFsKSA6OlxuICByZXR1cm4gdHQuX2ZvciA9PT0ga2V5d29yZFR5cGVcbiAgICAmJiB0dC5uYW1lID09PSB0eXBlXG4gICAgJiYgJ2F3YWl0JyA9PT0gdmFsXG5cbmNvbnN0IHJ4X29mZnNpZGVfb3AgPSAvKFxcUyspWyBcXHRdKihcXHJcXG58XFxyfFxcbik/L1xuXG5wcC5fYmFzZV9maW5pc2hUb2tlbiA9IGJhc2VQcm90by5maW5pc2hUb2tlblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIDo6XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVxuICBjb25zdCByZWNlbnRLZXl3b3JkID0gc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmRcbiAgY29uc3QgaW5Gb3JBd2FpdCA9IHJlY2VudEtleXdvcmQgPyB0aGlzLmlzRm9yQXdhaXQocmVjZW50S2V5d29yZCwgdHlwZSwgdmFsKSA6IG51bGxcbiAgc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmQgPSBudWxsXG5cbiAgaWYgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncy5oYXModHlwZSkgfHwgaW5Gb3JBd2FpdCA6OlxuICAgIGNvbnN0IGlzS2V5d29yZEFsbG93ZWQgPSAhdGhpcy5pc0xvb2thaGVhZFxuICAgICAgJiYgdHQuZG90ICE9PSBzdGF0ZS50eXBlXG5cbiAgICBpZiAhaXNLZXl3b3JkQWxsb3dlZCA6OlxuICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4odHlwZSwgdmFsKVxuXG4gICAgc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmQgPSBpbkZvckF3YWl0ID8gdHQuX2ZvciA6IHR5cGVcbiAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpXG5cbiAgICBpZiB0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAuaGFzKGxvb2thaGVhZC50eXBlKSA6OlxuICAgIGVsc2UgaWYgdGhpcy5pc0ZvckF3YWl0KHR5cGUsIGxvb2thaGVhZC50eXBlLCBsb29rYWhlYWQudmFsdWUpIDo6XG4gICAgZWxzZSA6OlxuICAgICAgc3RhdGUub2Zmc2lkZU5leHRPcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG5cbiAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgaWYgdHlwZSA9PT0gdHQuYXQgfHwgdHlwZSA9PT0gdHQuZG91YmxlQ29sb24gOjpcbiAgICBjb25zdCBwb3MwID0gc3RhdGUuc3RhcnQsIHBvczEgPSBzdGF0ZS5wb3MgKyAyXG4gICAgY29uc3QgbV9vcCA9IHJ4X29mZnNpZGVfb3AuZXhlYyBAIHRoaXMuaW5wdXQuc2xpY2UocG9zMClcbiAgICBjb25zdCBzdHJfb3AgPSBtX29wWzFdXG4gICAgY29uc3QgbGluZUVuZHNXaXRoT3AgPSAhISBtX29wWzJdXG5cbiAgICBsZXQgb3AgPSBhdF9vZmZzaWRlW3N0cl9vcF1cbiAgICBpZiBvcCA6OlxuICAgICAgaWYgb3Aua2V5d29yZEJsb2NrICYmIHJlY2VudEtleXdvcmQgJiYgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncy5oYXMocmVjZW50S2V5d29yZCkgOjpcbiAgICAgICAgb3AgPSBhdF9vZmZzaWRlLmtleXdvcmRfYXJnc1xuXG4gICAgICBlbHNlIGlmIGxpbmVFbmRzV2l0aE9wICYmIG9wLm5lc3RJbm5lcjo6XG4gICAgICAgIC8vIGFsbCBvZmZzaWRlIG9wZXJhdG9ycyBhdCB0aGUgZW5kIG9mIGEgbGluZSBpbXBsaWNpdGx5IGRvbid0IG5lc3RJbm5lclxuICAgICAgICBvcCA9IEB7fSBfX3Byb3RvX186IG9wLCBuZXN0SW5uZXI6IGZhbHNlXG5cbiAgICAgIHRoaXMuZmluaXNoT2Zmc2lkZU9wKG9wLCBvcC5leHRyYUNoYXJzKVxuXG4gICAgICBpZiBvcC5uZXN0T3AgOjpcbiAgICAgICAgc3RhdGUub2Zmc2lkZU5leHRPcCA9IGF0X29mZnNpZGVbb3AubmVzdE9wXVxuICAgICAgcmV0dXJuXG5cbiAgaWYgdHQuZW9mID09PSB0eXBlIDo6XG4gICAgaWYgc3RhdGUub2Zmc2lkZS5sZW5ndGggOjpcbiAgICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuXG5wcC5vZmZzaWRlSW5kZW50ID0gZnVuY3Rpb24gKGxpbmUwLCBvdXRlckluZGVudCwgaW5uZXJJbmRlbnQpIDo6XG4gIGNvbnN0IG9mZnNpZGVfbGluZXMgPSB0aGlzLm9mZnNpZGVfbGluZXNcblxuICBpZiBudWxsID09IGlubmVySW5kZW50IDo6XG4gICAgY29uc3QgaW5uZXJMaW5lID0gb2Zmc2lkZV9saW5lc1tsaW5lMCsxXVxuICAgIGlubmVySW5kZW50ID0gaW5uZXJMaW5lID8gaW5uZXJMaW5lLmluZGVudCA6ICcnXG5cbiAgbGV0IGxpbmU9bGluZTArMSwgbGFzdD1vZmZzaWRlX2xpbmVzW2xpbmUwXVxuICB3aGlsZSBsaW5lIDwgb2Zmc2lkZV9saW5lcy5sZW5ndGggOjpcbiAgICBjb25zdCBjdXIgPSBvZmZzaWRlX2xpbmVzW2xpbmVdXG4gICAgaWYgY3VyLmNvbnRlbnQgJiYgb3V0ZXJJbmRlbnQgPj0gY3VyLmluZGVudCA6OlxuICAgICAgbGluZS0tIC8vIGJhY2t1cCB0byBwcmV2aW91cyBsaW5lXG4gICAgICBicmVha1xuXG4gICAgbGluZSsrOyBsYXN0ID0gY3VyXG4gICAgaWYgaW5uZXJJbmRlbnQgPiBjdXIuaW5kZW50IDo6XG4gICAgICBpbm5lckluZGVudCA9IGN1ci5pbmRlbnRcblxuICByZXR1cm4gQHt9IGxpbmUsIGxhc3QsIGlubmVySW5kZW50XG5cblxucHAub2Zmc2lkZUJsb2NrID0gZnVuY3Rpb24gKG9wLCBzdGFja1RvcCwgcmVjZW50S2V5d29yZFRvcCkgOjpcbiAgY29uc3QgbGluZTAgPSB0aGlzLnN0YXRlLmN1ckxpbmVcbiAgY29uc3QgZmlyc3QgPSB0aGlzLm9mZnNpZGVfbGluZXNbbGluZTBdXG5cbiAgbGV0IGluZGVudCwga2V5d29yZE5lc3RlZEluZGVudFxuICBpZiByZWNlbnRLZXl3b3JkVG9wIDo6XG4gICAgaW5kZW50ID0gcmVjZW50S2V5d29yZFRvcC5maXJzdC5pbmRlbnRcbiAgZWxzZSBpZiBvcC5uZXN0SW5uZXIgJiYgc3RhY2tUb3AgJiYgbGluZTAgPT09IHN0YWNrVG9wLmZpcnN0LmxpbmUgOjpcbiAgICBpbmRlbnQgPSBzdGFja1RvcC5pbm5lckluZGVudFxuICBlbHNlIGlmIG9wLmluS2V5d29yZEFyZyA6OlxuICAgIGluZGVudCA9IGZpcnN0LmluZGVudFxuICAgIGNvbnN0IGluZGVudF9ibG9jayA9IHRoaXMub2Zmc2lkZUluZGVudChsaW5lMCwgaW5kZW50KVxuICAgIGNvbnN0IGluZGVudF9rZXl3b3JkID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQpXG4gICAgaWYgaW5kZW50X2tleXdvcmQuaW5uZXJJbmRlbnQgPiBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQgOjpcbiAgICAgIC8vIGF1dG9kZXRlY3Qga2V5d29yZCBhcmd1bWVudCB1c2luZyAnQCcgZm9yIGZ1bmN0aW9uIGNhbGxzXG4gICAgICBpbmRlbnQgPSBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnRcbiAgICAgIGtleXdvcmROZXN0ZWRJbmRlbnQgPSBpbmRlbnRfa2V5d29yZC5pbm5lckluZGVudFxuICBlbHNlIDo6XG4gICAgaW5kZW50ID0gZmlyc3QuaW5kZW50XG5cbiAgbGV0IHtsYXN0LCBpbm5lckluZGVudH0gPSB0aGlzLm9mZnNpZGVJbmRlbnQobGluZTAsIGluZGVudCwga2V5d29yZE5lc3RlZEluZGVudClcblxuICAvLyBjYXAgdG8gXG4gIGlubmVySW5kZW50ID0gZmlyc3QuaW5kZW50ID4gaW5uZXJJbmRlbnRcbiAgICA/IGZpcnN0LmluZGVudCA6IGlubmVySW5kZW50XG5cbiAgaWYgc3RhY2tUb3AgJiYgc3RhY2tUb3AubGFzdC5wb3NMYXN0Q29udGVudCA8IGxhc3QucG9zTGFzdENvbnRlbnQ6OlxuICAgIC8vIEZpeHVwIGVuY2xvc2luZyBzY29wZXMuIEhhcHBlbnMgaW4gc2l0dWF0aW9ucyBsaWtlOiBgc2VydmVyLm9uIEAgd3JhcGVyIEAgKC4uLmFyZ3MpID0+IDo6YFxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gICAgZm9yIGxldCBpZHggPSBzdGFjay5sZW5ndGgtMTsgaWR4PjA7IGlkeC0tIDo6XG4gICAgICBsZXQgdGlwID0gc3RhY2tbaWR4XVxuICAgICAgaWYgdGlwLmxhc3QucG9zTGFzdENvbnRlbnQgPj0gbGFzdC5wb3NMYXN0Q29udGVudCA6OiBicmVha1xuICAgICAgdGlwLmxhc3QgPSBsYXN0XG5cbiAgcmV0dXJuIHtvcCwgaW5uZXJJbmRlbnQsIGZpcnN0LCBsYXN0fVxuXG5cblxucHAuZmluaXNoT2Zmc2lkZU9wID0gZnVuY3Rpb24gKG9wLCBleHRyYUNoYXJzKSA6OlxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBsZXQgcmVjZW50S2V5d29yZFRvcFxuICBpZiBvcC5jb2RlQmxvY2sgOjpcbiAgICBpZiBzdGFja1RvcCAmJiBzdGFja1RvcC5pbktleXdvcmRBcmcgOjpcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSBlbmQgb2YgYW4gb2Zmc2lkZSBrZXl3b3JkIGJsb2NrOyByZXN0b3JlIGVuY2xvc2luZyAoKVxuICAgICAgdGhpcy5wb3BPZmZzaWRlKClcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG9wXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVSZWNlbnRUb3AgPSBzdGFja1RvcFxuICAgICAgcmV0dXJuXG5cbiAgICByZWNlbnRLZXl3b3JkVG9wID0gdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gbnVsbFxuXG4gIGlmIGV4dHJhQ2hhcnMgOjpcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBleHRyYUNoYXJzXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihvcC50b2tlblByZSlcblxuICBpZiB0aGlzLmlzTG9va2FoZWFkIDo6IHJldHVyblxuXG4gIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgY29uc3QgYmxrID0gdGhpcy5vZmZzaWRlQmxvY2sob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKVxuICBibGsuaW5LZXl3b3JkQXJnID0gb3AuaW5LZXl3b3JkQXJnIHx8IHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZ1xuICB0aGlzLnN0YXRlLm9mZnNpZGUucHVzaChibGspXG5cblxucHAuX2Jhc2Vfc2tpcFNwYWNlID0gYmFzZVByb3RvLnNraXBTcGFjZVxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSA6OlxuICBpZiBudWxsICE9PSB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgOjogcmV0dXJuXG5cbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wXG4gIGlmIHN0YWNrICYmIHN0YWNrLmxlbmd0aCA6OlxuICAgIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gc3RhY2tUb3AubGFzdC5wb3NMYXN0Q29udGVudFxuICBlbHNlIDo6IHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdHJ5IDo6XG4gICAgdGhpcy5fYmFzZV9za2lwU3BhY2UoKVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG4gIGNhdGNoIGVyciA6OlxuICAgIGlmIGVyciAhPT0gb2Zmc2lkZUJyZWFrb3V0IDo6IHRocm93IGVyclxuXG5cbnBwLl9iYXNlX3JlYWRUb2tlbiA9IGJhc2VQcm90by5yZWFkVG9rZW5cbnBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIDo6XG4gIGNvbnN0IG9mZnNpZGVOZXh0T3AgPSB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3BcbiAgaWYgbnVsbCAhPT0gb2Zmc2lkZU5leHRPcCA6OlxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG51bGxcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob2Zmc2lkZU5leHRPcClcblxuICBlbHNlIGlmIHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgOjpcbiAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICBlbHNlIDo6XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VfcmVhZFRva2VuKGNvZGUpXG5cbnBwLnBvcE9mZnNpZGUgPSBmdW5jdGlvbigpIDo6XG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGNvbnN0IHN0YWNrVG9wID0gdGhpcy5pc0xvb2thaGVhZFxuICAgID8gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgOiBzdGFjay5wb3AoKVxuICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4oc3RhY2tUb3Aub3AudG9rZW5Qb3N0KVxuICByZXR1cm4gc3RhY2tUb3BcbiJdfQ==