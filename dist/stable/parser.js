'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hookBabylon = hookBabylon;

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _offside_ops = require('./offside_ops');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const tt = babylon.tokTypes;

var _g_offsidePluginOpts;

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  const tgt_patch = tt.braceL;
  const fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = (0, _offside_ops.parseOffsideIndexMap)(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      const offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

const tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

const tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

pp.isForAwait = function (keywordType, type, val) {
  return tt._for === keywordType && tt.name === type && 'await' === val;
};

const rx_offside_op = /(\S+)[ \t]*(\r\n|\r|\n)?/;

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  const recentKeyword = state.offsideRecentKeyword;
  const inForAwait = recentKeyword ? this.isForAwait(recentKeyword, type, val) : null;
  state.offsideRecentKeyword = null;

  if (tt_offside_keyword_with_args.has(type) || inForAwait) {
    const isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    state.offsideRecentKeyword = inForAwait ? tt._for : type;
    const lookahead = this.lookahead();

    if (tt_offside_keyword_lookahead_skip.has(lookahead.type)) {} else if (this.isForAwait(type, lookahead.type, lookahead.value)) {} else {
      state.offsideNextOp = _offside_ops.at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const m_op = rx_offside_op.exec(this.input.slice(pos0));
    const str_op = m_op[1];
    const lineEndsWithOp = !!m_op[2];

    let op = _offside_ops.at_offside[str_op];
    if (op) {
      if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(recentKeyword)) {
        op = _offside_ops.at_offside.keyword_args;
      } else if (lineEndsWithOp && op.nestInner) {
        // all offside operators at the end of a line implicitly don't nestInner
        op = { __proto__: op, nestInner: false };
      }

      this.finishOffsideOp(op, op.extraChars);

      if (op.nestOp) {
        state.offsideNextOp = _offside_ops.at_offside[op.nestOp];
      }
      return;
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideIndent = function (line0, outerIndent, innerIndent) {
  const offside_lines = this.offside_lines;

  if (null == innerIndent) {
    const innerLine = offside_lines[line0 + 1];
    innerIndent = innerLine ? innerLine.indent : '';
  }

  let line = line0 + 1,
      last = offside_lines[line0];
  while (line < offside_lines.length) {
    const cur = offside_lines[line];
    if (cur.content && outerIndent >= cur.indent) {
      line--; // backup to previous line
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  return { line, last, innerIndent };
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  const state = this.state;
  const line0 = state.curLine;
  const first = this.offside_lines[line0];

  let indent, keywordNestedIndent;
  if (recentKeywordTop) {
    indent = recentKeywordTop.first.indent;
  } else if (op.nestInner && stackTop && line0 === stackTop.first.line) {
    indent = stackTop.innerIndent;
  } else if (op.inKeywordArg) {
    indent = first.indent;
    const indent_block = this.offsideIndent(line0, indent);
    const indent_keyword = this.offsideIndent(line0, indent_block.innerIndent);
    if (indent_keyword.innerIndent > indent_block.innerIndent) {
      // autodetect keyword argument using '@' for function calls
      indent = indent_block.innerIndent;
      keywordNestedIndent = indent_keyword.innerIndent;
    }
  } else {
    indent = first.indent;
  }

  let { last, innerIndent } = this.offsideIndent(line0, indent, keywordNestedIndent);

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  if (stackTop && stackTop.last.posLastContent < last.posLastContent) {
    // Fixup enclosing scopes. Happens in situations like: `server.on @ wraper @ (...args) => ::`
    const stack = state.offside;
    for (let idx = stack.length - 1; idx > 0; idx--) {
      let tip = stack[idx];
      if (tip.last.posLastContent >= last.posLastContent) {
        break;
      }
      tip.last = last;
    }
  }

  return { op, innerIndent, first, last,
    start: state.start, end: state.end,
    loc: { start: state.startLoc, end: state.endLoc } };
};

pp.finishOffsideOp = function (op, extraChars) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      // We're at the end of an offside keyword block; restore enclosing ()
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (extraChars) {
    this.state.pos += extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  const blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  const state = this.state;
  if (null !== state.offsideNextOp) {
    return;
  }

  const stack = state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    state.offsidePos = stackTop.last.posLastContent;
  } else {
    state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    state.offsidePos = -1;

    state.offsideImplicitComma = undefined !== stackTop ? this.offsideCheckImplicitComma(stackTop) : null;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp.offsideCheckImplicitComma = function (stackTop) {
  if (!stackTop.op.implicitCommas || !this.offsidePluginOpts.implicit_commas) {
    return false; // not enabled for this offside op
  }const state = this.state,
        column = state.pos - state.lineStart;
  if (column !== stackTop.innerIndent.length) {
    return false; // not at the exact right indent
  }if (stackTop.end >= state.end) {
    return false; // no comma before the first element
  }if (tt.comma === state.type) {
    return false; // there's an explicit comma already present
  }if (state.type.binop || state.type.beforeExpr) {
    return false; // there's an operator or arrow function preceeding this line
  }if (this.isLookahead) {
    return false; // disallow recursive lookahead
  }const lookahead = this.lookahead();
  if (tt.comma === lookahead.type) {
    return false; // there's an explicit comma present in the next token
  }console.log('GOTIME', state.type, state);
  return true; // a comma is needed
};pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const state = this.state;

  if (state.offsideImplicitComma) {
    return this._base_finishToken(tt.comma);
  }

  const offsideNextOp = state.offsideNextOp;
  if (null !== offsideNextOp) {
    state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  }

  if (state.pos === state.offsidePos) {
    return this.popOffside();
  }

  return this._base_readToken(code);
};

pp.popOffside = function () {
  const stack = this.state.offside;
  const stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2NvZGUvcGFyc2VyLmpzIl0sIm5hbWVzIjpbImhvb2tCYWJ5bG9uIiwiYmFieWxvbiIsInR0IiwidG9rVHlwZXMiLCJfZ19vZmZzaWRlUGx1Z2luT3B0cyIsIl9iYXNlX21vZHVsZV9wYXJzZSIsInBhcnNlIiwiaW5wdXQiLCJvcHRpb25zIiwib2Zmc2lkZVBsdWdpbk9wdHMiLCJ1bmRlZmluZWQiLCJQYXJzZXIiLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwiX3BvcyIsInBvcyIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInNldCIsIm9mZlBvcyIsIm9mZnNpZGVQb3MiLCJ0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzIiwiU2V0IiwiX2lmIiwiX3doaWxlIiwiX2ZvciIsIl9jYXRjaCIsIl9zd2l0Y2giLCJ0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAiLCJwYXJlbkwiLCJjb2xvbiIsImNvbW1hIiwiZG90IiwiaXNGb3JBd2FpdCIsImtleXdvcmRUeXBlIiwidHlwZSIsInZhbCIsIm5hbWUiLCJyeF9vZmZzaWRlX29wIiwiX2Jhc2VfZmluaXNoVG9rZW4iLCJmaW5pc2hUb2tlbiIsInJlY2VudEtleXdvcmQiLCJvZmZzaWRlUmVjZW50S2V5d29yZCIsImluRm9yQXdhaXQiLCJoYXMiLCJpc0tleXdvcmRBbGxvd2VkIiwiaXNMb29rYWhlYWQiLCJsb29rYWhlYWQiLCJ2YWx1ZSIsImtleXdvcmRfYXJncyIsImF0IiwiZG91YmxlQ29sb24iLCJwb3MwIiwic3RhcnQiLCJwb3MxIiwibV9vcCIsImV4ZWMiLCJzbGljZSIsInN0cl9vcCIsImxpbmVFbmRzV2l0aE9wIiwib3AiLCJrZXl3b3JkQmxvY2siLCJuZXN0SW5uZXIiLCJfX3Byb3RvX18iLCJmaW5pc2hPZmZzaWRlT3AiLCJleHRyYUNoYXJzIiwibmVzdE9wIiwiZW9mIiwibGVuZ3RoIiwicG9wT2Zmc2lkZSIsIm9mZnNpZGVJbmRlbnQiLCJsaW5lMCIsIm91dGVySW5kZW50IiwiaW5uZXJJbmRlbnQiLCJpbm5lckxpbmUiLCJpbmRlbnQiLCJsaW5lIiwibGFzdCIsImN1ciIsImNvbnRlbnQiLCJvZmZzaWRlQmxvY2siLCJzdGFja1RvcCIsInJlY2VudEtleXdvcmRUb3AiLCJjdXJMaW5lIiwiZmlyc3QiLCJrZXl3b3JkTmVzdGVkSW5kZW50IiwiaW5LZXl3b3JkQXJnIiwiaW5kZW50X2Jsb2NrIiwiaW5kZW50X2tleXdvcmQiLCJwb3NMYXN0Q29udGVudCIsInN0YWNrIiwiaWR4IiwidGlwIiwiZW5kIiwibG9jIiwic3RhcnRMb2MiLCJlbmRMb2MiLCJjb2RlQmxvY2siLCJvZmZzaWRlUmVjZW50VG9wIiwidG9rZW5QcmUiLCJibGsiLCJwdXNoIiwiX2Jhc2Vfc2tpcFNwYWNlIiwic2tpcFNwYWNlIiwib2Zmc2lkZUltcGxpY2l0Q29tbWEiLCJvZmZzaWRlQ2hlY2tJbXBsaWNpdENvbW1hIiwiZXJyIiwiaW1wbGljaXRDb21tYXMiLCJpbXBsaWNpdF9jb21tYXMiLCJjb2x1bW4iLCJsaW5lU3RhcnQiLCJiaW5vcCIsImJlZm9yZUV4cHIiLCJjb25zb2xlIiwibG9nIiwiX2Jhc2VfcmVhZFRva2VuIiwicmVhZFRva2VuIiwiY29kZSIsInBvcCIsInRva2VuUG9zdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFnQmdCQSxXLEdBQUFBLFc7O0FBaEJoQjs7SUFBWUMsTzs7QUFHWjs7OztBQUZBLE1BQU1DLEtBQUtELFFBQVFFLFFBQW5COztBQUlBLElBQUlD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MkgsU0FBL0I7QUFDQXpILEdBQUd5SCxTQUFILEdBQWUsVUFBU0MsSUFBVCxFQUFlO0FBQzVCLFFBQU01RyxRQUFRLEtBQUtBLEtBQW5COztBQUVBLE1BQUdBLE1BQU0rRixvQkFBVCxFQUFnQztBQUM5QixXQUFPLEtBQUtqRSxpQkFBTCxDQUF1QnhELEdBQUdnRCxLQUExQixDQUFQO0FBQXVDOztBQUV6QyxRQUFNcEIsZ0JBQWdCRixNQUFNRSxhQUE1QjtBQUNBLE1BQUcsU0FBU0EsYUFBWixFQUE0QjtBQUMxQkYsVUFBTUUsYUFBTixHQUFzQixJQUF0QjtBQUNBLFdBQU8sS0FBS3FELGVBQUwsQ0FBcUJyRCxhQUFyQixDQUFQO0FBQTBDOztBQUU1QyxNQUFHRixNQUFNSyxHQUFOLEtBQWNMLE1BQU1XLFVBQXZCLEVBQW9DO0FBQ2xDLFdBQU8sS0FBS2lELFVBQUwsRUFBUDtBQUF3Qjs7QUFFMUIsU0FBTyxLQUFLOEMsZUFBTCxDQUFxQkUsSUFBckIsQ0FBUDtBQUFpQyxDQWRuQzs7QUFnQkExSCxHQUFHMEUsVUFBSCxHQUFnQixZQUFXO0FBQ3pCLFFBQU1xQixRQUFRLEtBQUtqRixLQUFMLENBQVdDLE9BQXpCO0FBQ0EsUUFBTXVFLFdBQVcsS0FBS25DLFdBQUwsR0FDYjRDLE1BQU1BLE1BQU10QixNQUFOLEdBQWEsQ0FBbkIsQ0FEYSxHQUVic0IsTUFBTTRCLEdBQU4sRUFGSjtBQUdBLE9BQUs3RyxLQUFMLENBQVdXLFVBQVgsR0FBd0IsQ0FBQyxDQUF6Qjs7QUFFQSxPQUFLbUIsaUJBQUwsQ0FBdUIwQyxTQUFTckIsRUFBVCxDQUFZMkQsU0FBbkM7QUFDQSxTQUFPdEMsUUFBUDtBQUFlLENBUmpCIiwiZmlsZSI6InBhcnNlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGJhYnlsb24gZnJvbSAnYmFieWxvbidcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG5pbXBvcnQge2F0X29mZnNpZGUsIHBhcnNlT2Zmc2lkZUluZGV4TWFwfSBmcm9tICcuL29mZnNpZGVfb3BzJ1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcblxuY29uc3QgX2Jhc2VfbW9kdWxlX3BhcnNlID0gYmFieWxvbi5wYXJzZVxuYmFieWxvbi5wYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gOjpcbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBvcHRpb25zID8gb3B0aW9ucy5vZmZzaWRlUGx1Z2luT3B0cyA6IHVuZGVmaW5lZFxuICByZXR1cm4gX2Jhc2VfbW9kdWxlX3BhcnNlKGlucHV0LCBvcHRpb25zKVxuXG5jb25zdCBQYXJzZXIgPSBob29rQmFieWxvbigpXG5jb25zdCBiYXNlUHJvdG8gPSBQYXJzZXIucHJvdG90eXBlXG5jb25zdCBwcCA9IFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90bylcblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tCYWJ5bG9uKCkgOjpcbiAgLy8gYWJ1c2UgQmFieWxvbiB0b2tlbiB1cGRhdGVDb250ZXh0IGNhbGxiYWNrIGV4dHJhY3RcbiAgLy8gdGhlIHJlZmVyZW5jZSB0byBQYXJzZXJcblxuICBsZXQgUGFyc2VyXG4gIGNvbnN0IHRndF9wYXRjaCA9IHR0LmJyYWNlTFxuICBjb25zdCBmbl91cGRhdGVDb250ZXh0ID0gdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHRcbiAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIDo6XG4gICAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmbl91cGRhdGVDb250ZXh0XG4gICAgUGFyc2VyID0gdGhpcy5jb25zdHJ1Y3RvclxuXG4gIGJhYnlsb24ucGFyc2UoJ3t9JylcbiAgaWYgISBQYXJzZXIgOjpcbiAgICB0aHJvdyBuZXcgRXJyb3IgQCBcIkZhaWxlZCB0byBob29rIEJhYnlsb24gUGFyc2VyXCJcbiAgcmV0dXJuIFBhcnNlclxuXG5cbnBwLl9iYXNlX3BhcnNlID0gYmFzZVByb3RvLnBhcnNlXG5wcC5wYXJzZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5pbml0T2Zmc2lkZSgpXG4gIHJldHVybiB0aGlzLl9iYXNlX3BhcnNlKClcblxuXG5jbGFzcyBPZmZzaWRlQnJlYWtvdXQgZXh0ZW5kcyBFcnJvciB7fVxuY29uc3Qgb2Zmc2lkZUJyZWFrb3V0ID0gbmV3IE9mZnNpZGVCcmVha291dCgpXG5cbnBwLmluaXRPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICB0aGlzLnN0YXRlLm9mZnNpZGUgPSBbXVxuICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gIHRoaXMub2Zmc2lkZV9saW5lcyA9IHBhcnNlT2Zmc2lkZUluZGV4TWFwKHRoaXMuaW5wdXQpXG4gIHRoaXMub2Zmc2lkZVBsdWdpbk9wdHMgPSBfZ19vZmZzaWRlUGx1Z2luT3B0cyB8fCB7fVxuICBfZ19vZmZzaWRlUGx1Z2luT3B0cyA9IG51bGxcblxuICB0aGlzLnN0YXRlLl9wb3MgPSB0aGlzLnN0YXRlLnBvc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgQCB0aGlzLnN0YXRlLCAncG9zJyxcbiAgICBAe30gZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgLCBnZXQoKSA6OiByZXR1cm4gdGhpcy5fcG9zXG4gICAgICAsIHNldChwb3MpIDo6XG4gICAgICAgICAgLy8gaW50ZXJydXB0IHNraXBTcGFjZSBhbGdvcml0aG0gd2hlbiB3ZSBoaXQgb3VyIHBvc2l0aW9uICdicmVha3BvaW50J1xuICAgICAgICAgIGNvbnN0IG9mZlBvcyA9IHRoaXMub2Zmc2lkZVBvc1xuICAgICAgICAgIGlmIG9mZlBvcz49MCAmJiAocG9zID4gb2ZmUG9zKSA6OlxuICAgICAgICAgICAgdGhyb3cgb2Zmc2lkZUJyZWFrb3V0XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBwb3NcblxuXG5jb25zdCB0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzID0gbmV3IFNldCBAI1xuICAgICAgdHQuX2lmLCB0dC5fd2hpbGUsIHR0Ll9mb3JcbiAgICAsIHR0Ll9jYXRjaCwgdHQuX3N3aXRjaFxuXG5jb25zdCB0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAgPSBuZXcgU2V0IEAjXG4gICAgICB0dC5wYXJlbkwsIHR0LmNvbG9uLCB0dC5jb21tYSwgdHQuZG90XG5cbnBwLmlzRm9yQXdhaXQgPSBmdW5jdGlvbiAoa2V5d29yZFR5cGUsIHR5cGUsIHZhbCkgOjpcbiAgcmV0dXJuIHR0Ll9mb3IgPT09IGtleXdvcmRUeXBlXG4gICAgJiYgdHQubmFtZSA9PT0gdHlwZVxuICAgICYmICdhd2FpdCcgPT09IHZhbFxuXG5jb25zdCByeF9vZmZzaWRlX29wID0gLyhcXFMrKVsgXFx0XSooXFxyXFxufFxccnxcXG4pPy9cblxucHAuX2Jhc2VfZmluaXNoVG9rZW4gPSBiYXNlUHJvdG8uZmluaXNoVG9rZW5cbnBwLmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgY29uc3QgcmVjZW50S2V5d29yZCA9IHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkXG4gIGNvbnN0IGluRm9yQXdhaXQgPSByZWNlbnRLZXl3b3JkID8gdGhpcy5pc0ZvckF3YWl0KHJlY2VudEtleXdvcmQsIHR5cGUsIHZhbCkgOiBudWxsXG4gIHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkID0gbnVsbFxuXG4gIGlmIHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MuaGFzKHR5cGUpIHx8IGluRm9yQXdhaXQgOjpcbiAgICBjb25zdCBpc0tleXdvcmRBbGxvd2VkID0gIXRoaXMuaXNMb29rYWhlYWRcbiAgICAgICYmIHR0LmRvdCAhPT0gc3RhdGUudHlwZVxuXG4gICAgaWYgIWlzS2V5d29yZEFsbG93ZWQgOjpcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICAgIHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkID0gaW5Gb3JBd2FpdCA/IHR0Ll9mb3IgOiB0eXBlXG4gICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKVxuXG4gICAgaWYgdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwLmhhcyhsb29rYWhlYWQudHlwZSkgOjpcbiAgICBlbHNlIGlmIHRoaXMuaXNGb3JBd2FpdCh0eXBlLCBsb29rYWhlYWQudHlwZSwgbG9va2FoZWFkLnZhbHVlKSA6OlxuICAgIGVsc2UgOjpcbiAgICAgIHN0YXRlLm9mZnNpZGVOZXh0T3AgPSBhdF9vZmZzaWRlLmtleXdvcmRfYXJnc1xuXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4odHlwZSwgdmFsKVxuXG4gIGlmIHR5cGUgPT09IHR0LmF0IHx8IHR5cGUgPT09IHR0LmRvdWJsZUNvbG9uIDo6XG4gICAgY29uc3QgcG9zMCA9IHN0YXRlLnN0YXJ0LCBwb3MxID0gc3RhdGUucG9zICsgMlxuICAgIGNvbnN0IG1fb3AgPSByeF9vZmZzaWRlX29wLmV4ZWMgQCB0aGlzLmlucHV0LnNsaWNlKHBvczApXG4gICAgY29uc3Qgc3RyX29wID0gbV9vcFsxXVxuICAgIGNvbnN0IGxpbmVFbmRzV2l0aE9wID0gISEgbV9vcFsyXVxuXG4gICAgbGV0IG9wID0gYXRfb2Zmc2lkZVtzdHJfb3BdXG4gICAgaWYgb3AgOjpcbiAgICAgIGlmIG9wLmtleXdvcmRCbG9jayAmJiByZWNlbnRLZXl3b3JkICYmIHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MuaGFzKHJlY2VudEtleXdvcmQpIDo6XG4gICAgICAgIG9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcblxuICAgICAgZWxzZSBpZiBsaW5lRW5kc1dpdGhPcCAmJiBvcC5uZXN0SW5uZXI6OlxuICAgICAgICAvLyBhbGwgb2Zmc2lkZSBvcGVyYXRvcnMgYXQgdGhlIGVuZCBvZiBhIGxpbmUgaW1wbGljaXRseSBkb24ndCBuZXN0SW5uZXJcbiAgICAgICAgb3AgPSBAe30gX19wcm90b19fOiBvcCwgbmVzdElubmVyOiBmYWxzZVxuXG4gICAgICB0aGlzLmZpbmlzaE9mZnNpZGVPcChvcCwgb3AuZXh0cmFDaGFycylcblxuICAgICAgaWYgb3AubmVzdE9wIDo6XG4gICAgICAgIHN0YXRlLm9mZnNpZGVOZXh0T3AgPSBhdF9vZmZzaWRlW29wLm5lc3RPcF1cbiAgICAgIHJldHVyblxuXG4gIGlmIHR0LmVvZiA9PT0gdHlwZSA6OlxuICAgIGlmIHN0YXRlLm9mZnNpZGUubGVuZ3RoIDo6XG4gICAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cblxucHAub2Zmc2lkZUluZGVudCA9IGZ1bmN0aW9uIChsaW5lMCwgb3V0ZXJJbmRlbnQsIGlubmVySW5kZW50KSA6OlxuICBjb25zdCBvZmZzaWRlX2xpbmVzID0gdGhpcy5vZmZzaWRlX2xpbmVzXG5cbiAgaWYgbnVsbCA9PSBpbm5lckluZGVudCA6OlxuICAgIGNvbnN0IGlubmVyTGluZSA9IG9mZnNpZGVfbGluZXNbbGluZTArMV1cbiAgICBpbm5lckluZGVudCA9IGlubmVyTGluZSA/IGlubmVyTGluZS5pbmRlbnQgOiAnJ1xuXG4gIGxldCBsaW5lPWxpbmUwKzEsIGxhc3Q9b2Zmc2lkZV9saW5lc1tsaW5lMF1cbiAgd2hpbGUgbGluZSA8IG9mZnNpZGVfbGluZXMubGVuZ3RoIDo6XG4gICAgY29uc3QgY3VyID0gb2Zmc2lkZV9saW5lc1tsaW5lXVxuICAgIGlmIGN1ci5jb250ZW50ICYmIG91dGVySW5kZW50ID49IGN1ci5pbmRlbnQgOjpcbiAgICAgIGxpbmUtLSAvLyBiYWNrdXAgdG8gcHJldmlvdXMgbGluZVxuICAgICAgYnJlYWtcblxuICAgIGxpbmUrKzsgbGFzdCA9IGN1clxuICAgIGlmIGlubmVySW5kZW50ID4gY3VyLmluZGVudCA6OlxuICAgICAgaW5uZXJJbmRlbnQgPSBjdXIuaW5kZW50XG5cbiAgcmV0dXJuIEB7fSBsaW5lLCBsYXN0LCBpbm5lckluZGVudFxuXG5cbnBwLm9mZnNpZGVCbG9jayA9IGZ1bmN0aW9uIChvcCwgc3RhY2tUb3AsIHJlY2VudEtleXdvcmRUb3ApIDo6XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVxuICBjb25zdCBsaW5lMCA9IHN0YXRlLmN1ckxpbmVcbiAgY29uc3QgZmlyc3QgPSB0aGlzLm9mZnNpZGVfbGluZXNbbGluZTBdXG5cbiAgbGV0IGluZGVudCwga2V5d29yZE5lc3RlZEluZGVudFxuICBpZiByZWNlbnRLZXl3b3JkVG9wIDo6XG4gICAgaW5kZW50ID0gcmVjZW50S2V5d29yZFRvcC5maXJzdC5pbmRlbnRcbiAgZWxzZSBpZiBvcC5uZXN0SW5uZXIgJiYgc3RhY2tUb3AgJiYgbGluZTAgPT09IHN0YWNrVG9wLmZpcnN0LmxpbmUgOjpcbiAgICBpbmRlbnQgPSBzdGFja1RvcC5pbm5lckluZGVudFxuICBlbHNlIGlmIG9wLmluS2V5d29yZEFyZyA6OlxuICAgIGluZGVudCA9IGZpcnN0LmluZGVudFxuICAgIGNvbnN0IGluZGVudF9ibG9jayA9IHRoaXMub2Zmc2lkZUluZGVudChsaW5lMCwgaW5kZW50KVxuICAgIGNvbnN0IGluZGVudF9rZXl3b3JkID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQpXG4gICAgaWYgaW5kZW50X2tleXdvcmQuaW5uZXJJbmRlbnQgPiBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQgOjpcbiAgICAgIC8vIGF1dG9kZXRlY3Qga2V5d29yZCBhcmd1bWVudCB1c2luZyAnQCcgZm9yIGZ1bmN0aW9uIGNhbGxzXG4gICAgICBpbmRlbnQgPSBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnRcbiAgICAgIGtleXdvcmROZXN0ZWRJbmRlbnQgPSBpbmRlbnRfa2V5d29yZC5pbm5lckluZGVudFxuICBlbHNlIDo6XG4gICAgaW5kZW50ID0gZmlyc3QuaW5kZW50XG5cbiAgbGV0IHtsYXN0LCBpbm5lckluZGVudH0gPSB0aGlzLm9mZnNpZGVJbmRlbnQobGluZTAsIGluZGVudCwga2V5d29yZE5lc3RlZEluZGVudClcblxuICAvLyBjYXAgdG8gXG4gIGlubmVySW5kZW50ID0gZmlyc3QuaW5kZW50ID4gaW5uZXJJbmRlbnRcbiAgICA/IGZpcnN0LmluZGVudCA6IGlubmVySW5kZW50XG5cbiAgaWYgc3RhY2tUb3AgJiYgc3RhY2tUb3AubGFzdC5wb3NMYXN0Q29udGVudCA8IGxhc3QucG9zTGFzdENvbnRlbnQ6OlxuICAgIC8vIEZpeHVwIGVuY2xvc2luZyBzY29wZXMuIEhhcHBlbnMgaW4gc2l0dWF0aW9ucyBsaWtlOiBgc2VydmVyLm9uIEAgd3JhcGVyIEAgKC4uLmFyZ3MpID0+IDo6YFxuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUub2Zmc2lkZVxuICAgIGZvciBsZXQgaWR4ID0gc3RhY2subGVuZ3RoLTE7IGlkeD4wOyBpZHgtLSA6OlxuICAgICAgbGV0IHRpcCA9IHN0YWNrW2lkeF1cbiAgICAgIGlmIHRpcC5sYXN0LnBvc0xhc3RDb250ZW50ID49IGxhc3QucG9zTGFzdENvbnRlbnQgOjogYnJlYWtcbiAgICAgIHRpcC5sYXN0ID0gbGFzdFxuXG4gIHJldHVybiBAe30gb3AsIGlubmVySW5kZW50LCBmaXJzdCwgbGFzdFxuICAgICwgc3RhcnQ6IHN0YXRlLnN0YXJ0LCBlbmQ6IHN0YXRlLmVuZFxuICAgICwgbG9jOiBAe30gc3RhcnQ6IHN0YXRlLnN0YXJ0TG9jLCBlbmQ6IHN0YXRlLmVuZExvY1xuXG5cblxucHAuZmluaXNoT2Zmc2lkZU9wID0gZnVuY3Rpb24gKG9wLCBleHRyYUNoYXJzKSA6OlxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBsZXQgcmVjZW50S2V5d29yZFRvcFxuICBpZiBvcC5jb2RlQmxvY2sgOjpcbiAgICBpZiBzdGFja1RvcCAmJiBzdGFja1RvcC5pbktleXdvcmRBcmcgOjpcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSBlbmQgb2YgYW4gb2Zmc2lkZSBrZXl3b3JkIGJsb2NrOyByZXN0b3JlIGVuY2xvc2luZyAoKVxuICAgICAgdGhpcy5wb3BPZmZzaWRlKClcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG9wXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVSZWNlbnRUb3AgPSBzdGFja1RvcFxuICAgICAgcmV0dXJuXG5cbiAgICByZWNlbnRLZXl3b3JkVG9wID0gdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gbnVsbFxuXG4gIGlmIGV4dHJhQ2hhcnMgOjpcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBleHRyYUNoYXJzXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihvcC50b2tlblByZSlcblxuICBpZiB0aGlzLmlzTG9va2FoZWFkIDo6IHJldHVyblxuXG4gIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgY29uc3QgYmxrID0gdGhpcy5vZmZzaWRlQmxvY2sob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKVxuICBibGsuaW5LZXl3b3JkQXJnID0gb3AuaW5LZXl3b3JkQXJnIHx8IHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZ1xuICB0aGlzLnN0YXRlLm9mZnNpZGUucHVzaChibGspXG5cblxucHAuX2Jhc2Vfc2tpcFNwYWNlID0gYmFzZVByb3RvLnNraXBTcGFjZVxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgaWYgbnVsbCAhPT0gc3RhdGUub2Zmc2lkZU5leHRPcCA6OiByZXR1cm5cblxuICBjb25zdCBzdGFjayA9IHN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wXG4gIGlmIHN0YWNrICYmIHN0YWNrLmxlbmd0aCA6OlxuICAgIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgc3RhdGUub2Zmc2lkZVBvcyA9IHN0YWNrVG9wLmxhc3QucG9zTGFzdENvbnRlbnRcbiAgZWxzZSA6OiBzdGF0ZS5vZmZzaWRlUG9zID0gLTFcblxuICB0cnkgOjpcbiAgICB0aGlzLl9iYXNlX3NraXBTcGFjZSgpXG4gICAgc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgICBzdGF0ZS5vZmZzaWRlSW1wbGljaXRDb21tYSA9IHVuZGVmaW5lZCAhPT0gc3RhY2tUb3BcbiAgICAgID8gdGhpcy5vZmZzaWRlQ2hlY2tJbXBsaWNpdENvbW1hKHN0YWNrVG9wKVxuICAgICAgOiBudWxsXG4gIGNhdGNoIGVyciA6OlxuICAgIGlmIGVyciAhPT0gb2Zmc2lkZUJyZWFrb3V0IDo6IHRocm93IGVyclxuXG5wcC5vZmZzaWRlQ2hlY2tJbXBsaWNpdENvbW1hID0gZnVuY3Rpb24oc3RhY2tUb3ApIDo6XG4gIGlmICEgc3RhY2tUb3Aub3AuaW1wbGljaXRDb21tYXMgfHwgISB0aGlzLm9mZnNpZGVQbHVnaW5PcHRzLmltcGxpY2l0X2NvbW1hcyA6OlxuICAgIHJldHVybiBmYWxzZSAvLyBub3QgZW5hYmxlZCBmb3IgdGhpcyBvZmZzaWRlIG9wXG5cbiAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLCBjb2x1bW4gPSBzdGF0ZS5wb3MgLSBzdGF0ZS5saW5lU3RhcnRcbiAgaWYgY29sdW1uICE9PSBzdGFja1RvcC5pbm5lckluZGVudC5sZW5ndGggOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gbm90IGF0IHRoZSBleGFjdCByaWdodCBpbmRlbnRcbiAgaWYgc3RhY2tUb3AuZW5kID49IHN0YXRlLmVuZCA6OlxuICAgIHJldHVybiBmYWxzZSAvLyBubyBjb21tYSBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnRcbiAgaWYgdHQuY29tbWEgPT09IHN0YXRlLnR5cGUgOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gdGhlcmUncyBhbiBleHBsaWNpdCBjb21tYSBhbHJlYWR5IHByZXNlbnRcbiAgaWYgc3RhdGUudHlwZS5iaW5vcCB8fCBzdGF0ZS50eXBlLmJlZm9yZUV4cHIgOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gdGhlcmUncyBhbiBvcGVyYXRvciBvciBhcnJvdyBmdW5jdGlvbiBwcmVjZWVkaW5nIHRoaXMgbGluZVxuXG4gIGlmIHRoaXMuaXNMb29rYWhlYWQgOjogcmV0dXJuIGZhbHNlIC8vIGRpc2FsbG93IHJlY3Vyc2l2ZSBsb29rYWhlYWRcbiAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKVxuICBpZiB0dC5jb21tYSA9PT0gbG9va2FoZWFkLnR5cGUgOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gdGhlcmUncyBhbiBleHBsaWNpdCBjb21tYSBwcmVzZW50IGluIHRoZSBuZXh0IHRva2VuXG5cbiAgY29uc29sZS5sb2cgQCAnR09USU1FJywgc3RhdGUudHlwZSwgc3RhdGVcbiAgcmV0dXJuIHRydWUgLy8gYSBjb21tYSBpcyBuZWVkZWRcblxucHAuX2Jhc2VfcmVhZFRva2VuID0gYmFzZVByb3RvLnJlYWRUb2tlblxucHAucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkgOjpcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlXG5cbiAgaWYgc3RhdGUub2Zmc2lkZUltcGxpY2l0Q29tbWEgOjpcbiAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0dC5jb21tYSlcblxuICBjb25zdCBvZmZzaWRlTmV4dE9wID0gc3RhdGUub2Zmc2lkZU5leHRPcFxuICBpZiBudWxsICE9PSBvZmZzaWRlTmV4dE9wIDo6XG4gICAgc3RhdGUub2Zmc2lkZU5leHRPcCA9IG51bGxcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob2Zmc2lkZU5leHRPcClcblxuICBpZiBzdGF0ZS5wb3MgPT09IHN0YXRlLm9mZnNpZGVQb3MgOjpcbiAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICByZXR1cm4gdGhpcy5fYmFzZV9yZWFkVG9rZW4oY29kZSlcblxucHAucG9wT2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgY29uc3Qgc3RhY2tUb3AgPSB0aGlzLmlzTG9va2FoZWFkXG4gICAgPyBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICA6IHN0YWNrLnBvcCgpXG4gIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihzdGFja1RvcC5vcC50b2tlblBvc3QpXG4gIHJldHVybiBzdGFja1RvcFxuIl19