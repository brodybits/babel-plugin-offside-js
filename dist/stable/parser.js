'use strict';

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _offside_ops = require('./offside_ops');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const tt = babylon.tokTypes;

var _g_offsidePluginOpts;

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  const tgt_patch = tt.braceL;
  const fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = (0, _offside_ops.parseOffsideIndexMap)(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      const offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

const tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

const tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

pp.isForAwait = function (keywordType, type, val) {
  return tt._for === keywordType && tt.name === type && 'await' === val;
};

const rx_offside_op = /(\S+)[ \t]*(\r\n|\r|\n)?/;

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  const recentKeyword = state.offsideRecentKeyword;
  const inForAwait = recentKeyword ? this.isForAwait(recentKeyword, type, val) : null;
  state.offsideRecentKeyword = null;

  if (tt_offside_keyword_with_args.has(type) || inForAwait) {
    const isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    state.offsideRecentKeyword = inForAwait ? tt._for : type;
    const lookahead = this.lookahead();

    if (tt_offside_keyword_lookahead_skip.has(lookahead.type)) {} else if (this.isForAwait(type, lookahead.type, lookahead.value)) {} else {
      state.offsideNextOp = _offside_ops.at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const m_op = rx_offside_op.exec(this.input.slice(pos0));
    const str_op = m_op[1];
    const lineEndsWithOp = !!m_op[2];

    let op = _offside_ops.at_offside[str_op];
    if (op) {
      if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(recentKeyword)) {
        op = _offside_ops.at_offside.keyword_args;
      } else if (lineEndsWithOp && op.nestInner) {
        // all offside operators at the end of a line implicitly don't nestInner
        op = { __proto__: op, nestInner: false };
      }

      this.finishOffsideOp(op, op.extraChars);

      if (op.nestOp) {
        state.offsideNextOp = _offside_ops.at_offside[op.nestOp];
      }
      return;
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideIndent = function (line0, outerIndent, innerIndent) {
  const offside_lines = this.offside_lines;

  if (null == innerIndent) {
    const innerLine = offside_lines[line0 + 1];
    innerIndent = innerLine ? innerLine.indent : '';
  }

  let line = line0 + 1,
      last = offside_lines[line0];
  while (line < offside_lines.length) {
    const cur = offside_lines[line];
    if (cur.content && outerIndent >= cur.indent) {
      line--; // backup to previous line
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  return { line, last, innerIndent };
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  const state = this.state;
  const line0 = state.curLine;
  const first = this.offside_lines[line0];

  let indent, keywordNestedIndent;
  if (recentKeywordTop) {
    indent = recentKeywordTop.first.indent;
  } else if (op.nestInner && stackTop && line0 === stackTop.first.line) {
    indent = stackTop.innerIndent;
  } else if (op.inKeywordArg) {
    indent = first.indent;
    const indent_block = this.offsideIndent(line0, indent);
    const indent_keyword = this.offsideIndent(line0, indent_block.innerIndent);
    if (indent_keyword.innerIndent > indent_block.innerIndent) {
      // autodetect keyword argument using '@' for function calls
      indent = indent_block.innerIndent;
      keywordNestedIndent = indent_keyword.innerIndent;
    }
  } else {
    indent = first.indent;
  }

  let { last, innerIndent } = this.offsideIndent(line0, indent, keywordNestedIndent);

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  if (stackTop && stackTop.last.posLastContent < last.posLastContent) {
    // Fixup enclosing scopes. Happens in situations like: `server.on @ wraper @ (...args) => ::`
    const stack = state.offside;
    for (let idx = stack.length - 1; idx > 0; idx--) {
      let tip = stack[idx];
      if (tip.last.posLastContent >= last.posLastContent) {
        break;
      }
      tip.last = last;
    }
  }

  return { op, innerIndent, first, last,
    start: state.start, end: state.end,
    loc: { start: state.startLoc, end: state.endLoc } };
};

pp.finishOffsideOp = function (op, extraChars) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      // We're at the end of an offside keyword block; restore enclosing ()
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (extraChars) {
    this.state.pos += extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  const blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  const state = this.state;
  if (null !== state.offsideNextOp) {
    return;
  }

  const stack = state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    state.offsidePos = stackTop.last.posLastContent;
  } else {
    state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    state.offsidePos = -1;

    state.offsideImplicitComma = undefined !== stackTop ? this.offsideCheckImplicitComma(stackTop) : null;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp.offsideCheckImplicitComma = function (stackTop) {
  if (!stackTop.op.implicitCommas || !this.offsidePluginOpts.implicit_commas) {
    return false; // not enabled for this offside op
  }const state = this.state,
        column = state.pos - state.lineStart;
  if (column !== stackTop.innerIndent.length) {
    return false; // not at the exact right indent
  }if (stackTop.end >= state.end) {
    return false; // no comma before the first element
  }if (tt.comma === state.type) {
    return false; // there's an explicit comma already present
  }if (state.type.binop || state.type.beforeExpr) {
    if (state.type.beforeExpr) {
      console.log('beforeExpr', state.type);
    }
    return false; // there's an operator preceeding this line
  }if (this.isLookahead) {
    return false; // disallow recursive lookahead
  }const lookahead = this.lookahead();
  if (tt.comma === lookahead.type) {
    return false; // there's an explicit comma present in the next token
  }console.log('GOTIME', state.type, state);
  return true; // a comma is needed
};pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const state = this.state;

  if (state.offsideImplicitComma) {
    return this._base_finishToken(tt.comma);
  }

  const offsideNextOp = state.offsideNextOp;
  if (null !== offsideNextOp) {
    state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  }

  if (state.pos === state.offsidePos) {
    return this.popOffside();
  }

  return this._base_readToken(code);
};

pp.popOffside = function () {
  const stack = this.state.offside;
  const stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2NvZGUvcGFyc2VyLmpzIl0sIm5hbWVzIjpbImJhYnlsb24iLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwiX3BvcyIsInBvcyIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInNldCIsIm9mZlBvcyIsIm9mZnNpZGVQb3MiLCJ0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzIiwiU2V0IiwiX2lmIiwiX3doaWxlIiwiX2ZvciIsIl9jYXRjaCIsIl9zd2l0Y2giLCJ0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAiLCJwYXJlbkwiLCJjb2xvbiIsImNvbW1hIiwiZG90IiwiaXNGb3JBd2FpdCIsImtleXdvcmRUeXBlIiwidHlwZSIsInZhbCIsIm5hbWUiLCJyeF9vZmZzaWRlX29wIiwiX2Jhc2VfZmluaXNoVG9rZW4iLCJmaW5pc2hUb2tlbiIsInJlY2VudEtleXdvcmQiLCJvZmZzaWRlUmVjZW50S2V5d29yZCIsImluRm9yQXdhaXQiLCJoYXMiLCJpc0tleXdvcmRBbGxvd2VkIiwiaXNMb29rYWhlYWQiLCJsb29rYWhlYWQiLCJ2YWx1ZSIsImtleXdvcmRfYXJncyIsImF0IiwiZG91YmxlQ29sb24iLCJwb3MwIiwic3RhcnQiLCJwb3MxIiwibV9vcCIsImV4ZWMiLCJzbGljZSIsInN0cl9vcCIsImxpbmVFbmRzV2l0aE9wIiwib3AiLCJrZXl3b3JkQmxvY2siLCJuZXN0SW5uZXIiLCJfX3Byb3RvX18iLCJmaW5pc2hPZmZzaWRlT3AiLCJleHRyYUNoYXJzIiwibmVzdE9wIiwiZW9mIiwibGVuZ3RoIiwicG9wT2Zmc2lkZSIsIm9mZnNpZGVJbmRlbnQiLCJsaW5lMCIsIm91dGVySW5kZW50IiwiaW5uZXJJbmRlbnQiLCJpbm5lckxpbmUiLCJpbmRlbnQiLCJsaW5lIiwibGFzdCIsImN1ciIsImNvbnRlbnQiLCJvZmZzaWRlQmxvY2siLCJzdGFja1RvcCIsInJlY2VudEtleXdvcmRUb3AiLCJjdXJMaW5lIiwiZmlyc3QiLCJrZXl3b3JkTmVzdGVkSW5kZW50IiwiaW5LZXl3b3JkQXJnIiwiaW5kZW50X2Jsb2NrIiwiaW5kZW50X2tleXdvcmQiLCJwb3NMYXN0Q29udGVudCIsInN0YWNrIiwiaWR4IiwidGlwIiwiZW5kIiwibG9jIiwic3RhcnRMb2MiLCJlbmRMb2MiLCJjb2RlQmxvY2siLCJvZmZzaWRlUmVjZW50VG9wIiwidG9rZW5QcmUiLCJibGsiLCJwdXNoIiwiX2Jhc2Vfc2tpcFNwYWNlIiwic2tpcFNwYWNlIiwib2Zmc2lkZUltcGxpY2l0Q29tbWEiLCJvZmZzaWRlQ2hlY2tJbXBsaWNpdENvbW1hIiwiZXJyIiwiaW1wbGljaXRDb21tYXMiLCJpbXBsaWNpdF9jb21tYXMiLCJjb2x1bW4iLCJsaW5lU3RhcnQiLCJiaW5vcCIsImJlZm9yZUV4cHIiLCJjb25zb2xlIiwibG9nIiwiX2Jhc2VfcmVhZFRva2VuIiwicmVhZFRva2VuIiwiY29kZSIsInBvcCIsInRva2VuUG9zdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7SUFBWUEsTzs7QUFHWjs7OztBQUZBLE1BQU1DLEtBQUtELFFBQVFFLFFBQW5COztBQUlBLElBQUlDLG9CQUFKOztBQUVBLE1BQU1DLHFCQUFx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O0FBQ0EsU0FBTyxJQUFQLENBdEJnRCxDQXNCcEM7QUFBb0IsQ0F0QmxDLENBd0JBZCxHQUFHd0gsZUFBSCxHQUFxQjFILFVBQVUySCxTQUEvQjtBQUNBekgsR0FBR3lILFNBQUgsR0FBZSxVQUFTQyxJQUFULEVBQWU7QUFDNUIsUUFBTTVHLFFBQVEsS0FBS0EsS0FBbkI7O0FBRUEsTUFBR0EsTUFBTStGLG9CQUFULEVBQWdDO0FBQzlCLFdBQU8sS0FBS2pFLGlCQUFMLENBQXVCekQsR0FBR2lELEtBQTFCLENBQVA7QUFBdUM7O0FBRXpDLFFBQU1wQixnQkFBZ0JGLE1BQU1FLGFBQTVCO0FBQ0EsTUFBRyxTQUFTQSxhQUFaLEVBQTRCO0FBQzFCRixVQUFNRSxhQUFOLEdBQXNCLElBQXRCO0FBQ0EsV0FBTyxLQUFLcUQsZUFBTCxDQUFxQnJELGFBQXJCLENBQVA7QUFBMEM7O0FBRTVDLE1BQUdGLE1BQU1LLEdBQU4sS0FBY0wsTUFBTVcsVUFBdkIsRUFBb0M7QUFDbEMsV0FBTyxLQUFLaUQsVUFBTCxFQUFQO0FBQXdCOztBQUUxQixTQUFPLEtBQUs4QyxlQUFMLENBQXFCRSxJQUFyQixDQUFQO0FBQWlDLENBZG5DOztBQWdCQTFILEdBQUcwRSxVQUFILEdBQWdCLFlBQVc7QUFDekIsUUFBTXFCLFFBQVEsS0FBS2pGLEtBQUwsQ0FBV0MsT0FBekI7QUFDQSxRQUFNdUUsV0FBVyxLQUFLbkMsV0FBTCxHQUNiNEMsTUFBTUEsTUFBTXRCLE1BQU4sR0FBYSxDQUFuQixDQURhLEdBRWJzQixNQUFNNEIsR0FBTixFQUZKO0FBR0EsT0FBSzdHLEtBQUwsQ0FBV1csVUFBWCxHQUF3QixDQUFDLENBQXpCOztBQUVBLE9BQUttQixpQkFBTCxDQUF1QjBDLFNBQVNyQixFQUFULENBQVkyRCxTQUFuQztBQUNBLFNBQU90QyxRQUFQO0FBQWUsQ0FSakIiLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFieWxvbiBmcm9tICdiYWJ5bG9uJ1xuY29uc3QgdHQgPSBiYWJ5bG9uLnRva1R5cGVzXG5cbmltcG9ydCB7YXRfb2Zmc2lkZSwgcGFyc2VPZmZzaWRlSW5kZXhNYXB9IGZyb20gJy4vb2Zmc2lkZV9vcHMnXG5cbnZhciBfZ19vZmZzaWRlUGx1Z2luT3B0c1xuXG5jb25zdCBfYmFzZV9tb2R1bGVfcGFyc2UgPSBiYWJ5bG9uLnBhcnNlXG5iYWJ5bG9uLnBhcnNlID0gKGlucHV0LCBvcHRpb25zKSA9PiA6OlxuICBfZ19vZmZzaWRlUGx1Z2luT3B0cyA9IG9wdGlvbnMgPyBvcHRpb25zLm9mZnNpZGVQbHVnaW5PcHRzIDogdW5kZWZpbmVkXG4gIHJldHVybiBfYmFzZV9tb2R1bGVfcGFyc2UoaW5wdXQsIG9wdGlvbnMpXG5cbmNvbnN0IFBhcnNlciA9IGhvb2tCYWJ5bG9uKClcbmNvbnN0IGJhc2VQcm90byA9IFBhcnNlci5wcm90b3R5cGVcbmNvbnN0IHBwID0gUGFyc2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3RvKVxuXG5mdW5jdGlvbiBob29rQmFieWxvbigpIDo6XG4gIC8vIGFidXNlIEJhYnlsb24gdG9rZW4gdXBkYXRlQ29udGV4dCBjYWxsYmFjayBleHRyYWN0XG4gIC8vIHRoZSByZWZlcmVuY2UgdG8gUGFyc2VyXG5cbiAgbGV0IFBhcnNlclxuICBjb25zdCB0Z3RfcGF0Y2ggPSB0dC5icmFjZUxcbiAgY29uc3QgZm5fdXBkYXRlQ29udGV4dCA9IHRndF9wYXRjaC51cGRhdGVDb250ZXh0XG4gIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSA6OlxuICAgIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZm5fdXBkYXRlQ29udGV4dFxuICAgIFBhcnNlciA9IHRoaXMuY29uc3RydWN0b3JcblxuICBiYWJ5bG9uLnBhcnNlKCd7fScpXG4gIGlmICEgUGFyc2VyIDo6XG4gICAgdGhyb3cgbmV3IEVycm9yIEAgXCJGYWlsZWQgdG8gaG9vayBCYWJ5bG9uIFBhcnNlclwiXG4gIHJldHVybiBQYXJzZXJcblxuXG5wcC5fYmFzZV9wYXJzZSA9IGJhc2VQcm90by5wYXJzZVxucHAucGFyc2UgPSBmdW5jdGlvbigpIDo6XG4gIHRoaXMuaW5pdE9mZnNpZGUoKVxuICByZXR1cm4gdGhpcy5fYmFzZV9wYXJzZSgpXG5cblxuY2xhc3MgT2Zmc2lkZUJyZWFrb3V0IGV4dGVuZHMgRXJyb3Ige31cbmNvbnN0IG9mZnNpZGVCcmVha291dCA9IG5ldyBPZmZzaWRlQnJlYWtvdXQoKVxuXG5wcC5pbml0T2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlID0gW11cbiAgdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wID0gbnVsbFxuICB0aGlzLm9mZnNpZGVfbGluZXMgPSBwYXJzZU9mZnNpZGVJbmRleE1hcCh0aGlzLmlucHV0KVxuICB0aGlzLm9mZnNpZGVQbHVnaW5PcHRzID0gX2dfb2Zmc2lkZVBsdWdpbk9wdHMgfHwge31cbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBudWxsXG5cbiAgdGhpcy5zdGF0ZS5fcG9zID0gdGhpcy5zdGF0ZS5wb3NcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5IEAgdGhpcy5zdGF0ZSwgJ3BvcycsXG4gICAgQHt9IGVudW1lcmFibGU6IHRydWVcbiAgICAgICwgZ2V0KCkgOjogcmV0dXJuIHRoaXMuX3Bvc1xuICAgICAgLCBzZXQocG9zKSA6OlxuICAgICAgICAgIC8vIGludGVycnVwdCBza2lwU3BhY2UgYWxnb3JpdGhtIHdoZW4gd2UgaGl0IG91ciBwb3NpdGlvbiAnYnJlYWtwb2ludCdcbiAgICAgICAgICBjb25zdCBvZmZQb3MgPSB0aGlzLm9mZnNpZGVQb3NcbiAgICAgICAgICBpZiBvZmZQb3M+PTAgJiYgKHBvcyA+IG9mZlBvcykgOjpcbiAgICAgICAgICAgIHRocm93IG9mZnNpZGVCcmVha291dFxuXG4gICAgICAgICAgdGhpcy5fcG9zID0gcG9zXG5cblxuY29uc3QgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncyA9IG5ldyBTZXQgQCNcbiAgICAgIHR0Ll9pZiwgdHQuX3doaWxlLCB0dC5fZm9yXG4gICAgLCB0dC5fY2F0Y2gsIHR0Ll9zd2l0Y2hcblxuY29uc3QgdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwID0gbmV3IFNldCBAI1xuICAgICAgdHQucGFyZW5MLCB0dC5jb2xvbiwgdHQuY29tbWEsIHR0LmRvdFxuXG5wcC5pc0ZvckF3YWl0ID0gZnVuY3Rpb24gKGtleXdvcmRUeXBlLCB0eXBlLCB2YWwpIDo6XG4gIHJldHVybiB0dC5fZm9yID09PSBrZXl3b3JkVHlwZVxuICAgICYmIHR0Lm5hbWUgPT09IHR5cGVcbiAgICAmJiAnYXdhaXQnID09PSB2YWxcblxuY29uc3Qgcnhfb2Zmc2lkZV9vcCA9IC8oXFxTKylbIFxcdF0qKFxcclxcbnxcXHJ8XFxuKT8vXG5cbnBwLl9iYXNlX2ZpbmlzaFRva2VuID0gYmFzZVByb3RvLmZpbmlzaFRva2VuXG5wcC5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkgOjpcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlXG4gIGNvbnN0IHJlY2VudEtleXdvcmQgPSBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZFxuICBjb25zdCBpbkZvckF3YWl0ID0gcmVjZW50S2V5d29yZCA/IHRoaXMuaXNGb3JBd2FpdChyZWNlbnRLZXl3b3JkLCB0eXBlLCB2YWwpIDogbnVsbFxuICBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZCA9IG51bGxcblxuICBpZiB0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyh0eXBlKSB8fCBpbkZvckF3YWl0IDo6XG4gICAgY29uc3QgaXNLZXl3b3JkQWxsb3dlZCA9ICF0aGlzLmlzTG9va2FoZWFkXG4gICAgICAmJiB0dC5kb3QgIT09IHN0YXRlLnR5cGVcblxuICAgIGlmICFpc0tleXdvcmRBbGxvd2VkIDo6XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgICBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZCA9IGluRm9yQXdhaXQgPyB0dC5fZm9yIDogdHlwZVxuICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKClcblxuICAgIGlmIHR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcC5oYXMobG9va2FoZWFkLnR5cGUpIDo6XG4gICAgZWxzZSBpZiB0aGlzLmlzRm9yQXdhaXQodHlwZSwgbG9va2FoZWFkLnR5cGUsIGxvb2thaGVhZC52YWx1ZSkgOjpcbiAgICBlbHNlIDo6XG4gICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcblxuICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICBpZiB0eXBlID09PSB0dC5hdCB8fCB0eXBlID09PSB0dC5kb3VibGVDb2xvbiA6OlxuICAgIGNvbnN0IHBvczAgPSBzdGF0ZS5zdGFydCwgcG9zMSA9IHN0YXRlLnBvcyArIDJcbiAgICBjb25zdCBtX29wID0gcnhfb2Zmc2lkZV9vcC5leGVjIEAgdGhpcy5pbnB1dC5zbGljZShwb3MwKVxuICAgIGNvbnN0IHN0cl9vcCA9IG1fb3BbMV1cbiAgICBjb25zdCBsaW5lRW5kc1dpdGhPcCA9ICEhIG1fb3BbMl1cblxuICAgIGxldCBvcCA9IGF0X29mZnNpZGVbc3RyX29wXVxuICAgIGlmIG9wIDo6XG4gICAgICBpZiBvcC5rZXl3b3JkQmxvY2sgJiYgcmVjZW50S2V5d29yZCAmJiB0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyhyZWNlbnRLZXl3b3JkKSA6OlxuICAgICAgICBvcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG5cbiAgICAgIGVsc2UgaWYgbGluZUVuZHNXaXRoT3AgJiYgb3AubmVzdElubmVyOjpcbiAgICAgICAgLy8gYWxsIG9mZnNpZGUgb3BlcmF0b3JzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIGltcGxpY2l0bHkgZG9uJ3QgbmVzdElubmVyXG4gICAgICAgIG9wID0gQHt9IF9fcHJvdG9fXzogb3AsIG5lc3RJbm5lcjogZmFsc2VcblxuICAgICAgdGhpcy5maW5pc2hPZmZzaWRlT3Aob3AsIG9wLmV4dHJhQ2hhcnMpXG5cbiAgICAgIGlmIG9wLm5lc3RPcCA6OlxuICAgICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZVtvcC5uZXN0T3BdXG4gICAgICByZXR1cm5cblxuICBpZiB0dC5lb2YgPT09IHR5cGUgOjpcbiAgICBpZiBzdGF0ZS5vZmZzaWRlLmxlbmd0aCA6OlxuICAgICAgcmV0dXJuIHRoaXMucG9wT2Zmc2lkZSgpXG5cbiAgcmV0dXJuIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4odHlwZSwgdmFsKVxuXG5cbnBwLm9mZnNpZGVJbmRlbnQgPSBmdW5jdGlvbiAobGluZTAsIG91dGVySW5kZW50LCBpbm5lckluZGVudCkgOjpcbiAgY29uc3Qgb2Zmc2lkZV9saW5lcyA9IHRoaXMub2Zmc2lkZV9saW5lc1xuXG4gIGlmIG51bGwgPT0gaW5uZXJJbmRlbnQgOjpcbiAgICBjb25zdCBpbm5lckxpbmUgPSBvZmZzaWRlX2xpbmVzW2xpbmUwKzFdXG4gICAgaW5uZXJJbmRlbnQgPSBpbm5lckxpbmUgPyBpbm5lckxpbmUuaW5kZW50IDogJydcblxuICBsZXQgbGluZT1saW5lMCsxLCBsYXN0PW9mZnNpZGVfbGluZXNbbGluZTBdXG4gIHdoaWxlIGxpbmUgPCBvZmZzaWRlX2xpbmVzLmxlbmd0aCA6OlxuICAgIGNvbnN0IGN1ciA9IG9mZnNpZGVfbGluZXNbbGluZV1cbiAgICBpZiBjdXIuY29udGVudCAmJiBvdXRlckluZGVudCA+PSBjdXIuaW5kZW50IDo6XG4gICAgICBsaW5lLS0gLy8gYmFja3VwIHRvIHByZXZpb3VzIGxpbmVcbiAgICAgIGJyZWFrXG5cbiAgICBsaW5lKys7IGxhc3QgPSBjdXJcbiAgICBpZiBpbm5lckluZGVudCA+IGN1ci5pbmRlbnQgOjpcbiAgICAgIGlubmVySW5kZW50ID0gY3VyLmluZGVudFxuXG4gIHJldHVybiBAe30gbGluZSwgbGFzdCwgaW5uZXJJbmRlbnRcblxuXG5wcC5vZmZzaWRlQmxvY2sgPSBmdW5jdGlvbiAob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgY29uc3QgbGluZTAgPSBzdGF0ZS5jdXJMaW5lXG4gIGNvbnN0IGZpcnN0ID0gdGhpcy5vZmZzaWRlX2xpbmVzW2xpbmUwXVxuXG4gIGxldCBpbmRlbnQsIGtleXdvcmROZXN0ZWRJbmRlbnRcbiAgaWYgcmVjZW50S2V5d29yZFRvcCA6OlxuICAgIGluZGVudCA9IHJlY2VudEtleXdvcmRUb3AuZmlyc3QuaW5kZW50XG4gIGVsc2UgaWYgb3AubmVzdElubmVyICYmIHN0YWNrVG9wICYmIGxpbmUwID09PSBzdGFja1RvcC5maXJzdC5saW5lIDo6XG4gICAgaW5kZW50ID0gc3RhY2tUb3AuaW5uZXJJbmRlbnRcbiAgZWxzZSBpZiBvcC5pbktleXdvcmRBcmcgOjpcbiAgICBpbmRlbnQgPSBmaXJzdC5pbmRlbnRcbiAgICBjb25zdCBpbmRlbnRfYmxvY2sgPSB0aGlzLm9mZnNpZGVJbmRlbnQobGluZTAsIGluZGVudClcbiAgICBjb25zdCBpbmRlbnRfa2V5d29yZCA9IHRoaXMub2Zmc2lkZUluZGVudChsaW5lMCwgaW5kZW50X2Jsb2NrLmlubmVySW5kZW50KVxuICAgIGlmIGluZGVudF9rZXl3b3JkLmlubmVySW5kZW50ID4gaW5kZW50X2Jsb2NrLmlubmVySW5kZW50IDo6XG4gICAgICAvLyBhdXRvZGV0ZWN0IGtleXdvcmQgYXJndW1lbnQgdXNpbmcgJ0AnIGZvciBmdW5jdGlvbiBjYWxsc1xuICAgICAgaW5kZW50ID0gaW5kZW50X2Jsb2NrLmlubmVySW5kZW50XG4gICAgICBrZXl3b3JkTmVzdGVkSW5kZW50ID0gaW5kZW50X2tleXdvcmQuaW5uZXJJbmRlbnRcbiAgZWxzZSA6OlxuICAgIGluZGVudCA9IGZpcnN0LmluZGVudFxuXG4gIGxldCB7bGFzdCwgaW5uZXJJbmRlbnR9ID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnQsIGtleXdvcmROZXN0ZWRJbmRlbnQpXG5cbiAgLy8gY2FwIHRvIFxuICBpbm5lckluZGVudCA9IGZpcnN0LmluZGVudCA+IGlubmVySW5kZW50XG4gICAgPyBmaXJzdC5pbmRlbnQgOiBpbm5lckluZGVudFxuXG4gIGlmIHN0YWNrVG9wICYmIHN0YWNrVG9wLmxhc3QucG9zTGFzdENvbnRlbnQgPCBsYXN0LnBvc0xhc3RDb250ZW50OjpcbiAgICAvLyBGaXh1cCBlbmNsb3Npbmcgc2NvcGVzLiBIYXBwZW5zIGluIHNpdHVhdGlvbnMgbGlrZTogYHNlcnZlci5vbiBAIHdyYXBlciBAICguLi5hcmdzKSA9PiA6OmBcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLm9mZnNpZGVcbiAgICBmb3IgbGV0IGlkeCA9IHN0YWNrLmxlbmd0aC0xOyBpZHg+MDsgaWR4LS0gOjpcbiAgICAgIGxldCB0aXAgPSBzdGFja1tpZHhdXG4gICAgICBpZiB0aXAubGFzdC5wb3NMYXN0Q29udGVudCA+PSBsYXN0LnBvc0xhc3RDb250ZW50IDo6IGJyZWFrXG4gICAgICB0aXAubGFzdCA9IGxhc3RcblxuICByZXR1cm4gQHt9IG9wLCBpbm5lckluZGVudCwgZmlyc3QsIGxhc3RcbiAgICAsIHN0YXJ0OiBzdGF0ZS5zdGFydCwgZW5kOiBzdGF0ZS5lbmRcbiAgICAsIGxvYzogQHt9IHN0YXJ0OiBzdGF0ZS5zdGFydExvYywgZW5kOiBzdGF0ZS5lbmRMb2NcblxuXG5cbnBwLmZpbmlzaE9mZnNpZGVPcCA9IGZ1bmN0aW9uIChvcCwgZXh0cmFDaGFycykgOjpcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgbGV0IHJlY2VudEtleXdvcmRUb3BcbiAgaWYgb3AuY29kZUJsb2NrIDo6XG4gICAgaWYgc3RhY2tUb3AgJiYgc3RhY2tUb3AuaW5LZXl3b3JkQXJnIDo6XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIGFuIG9mZnNpZGUga2V5d29yZCBibG9jazsgcmVzdG9yZSBlbmNsb3NpbmcgKClcbiAgICAgIHRoaXMucG9wT2Zmc2lkZSgpXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBvcFxuICAgICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gc3RhY2tUb3BcbiAgICAgIHJldHVyblxuXG4gICAgcmVjZW50S2V5d29yZFRvcCA9IHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcFxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcCA9IG51bGxcblxuICBpZiBleHRyYUNoYXJzIDo6XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gZXh0cmFDaGFyc1xuXG4gIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4ob3AudG9rZW5QcmUpXG5cbiAgaWYgdGhpcy5pc0xvb2thaGVhZCA6OiByZXR1cm5cblxuICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gIGNvbnN0IGJsayA9IHRoaXMub2Zmc2lkZUJsb2NrKG9wLCBzdGFja1RvcCwgcmVjZW50S2V5d29yZFRvcClcbiAgYmxrLmluS2V5d29yZEFyZyA9IG9wLmluS2V5d29yZEFyZyB8fCBzdGFja1RvcCAmJiBzdGFja1RvcC5pbktleXdvcmRBcmdcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlLnB1c2goYmxrKVxuXG5cbnBwLl9iYXNlX3NraXBTcGFjZSA9IGJhc2VQcm90by5za2lwU3BhY2VcbnBwLnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkgOjpcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlXG4gIGlmIG51bGwgIT09IHN0YXRlLm9mZnNpZGVOZXh0T3AgOjogcmV0dXJuXG5cbiAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcFxuICBpZiBzdGFjayAmJiBzdGFjay5sZW5ndGggOjpcbiAgICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIHN0YXRlLm9mZnNpZGVQb3MgPSBzdGFja1RvcC5sYXN0LnBvc0xhc3RDb250ZW50XG4gIGVsc2UgOjogc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdHJ5IDo6XG4gICAgdGhpcy5fYmFzZV9za2lwU3BhY2UoKVxuICAgIHN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gICAgc3RhdGUub2Zmc2lkZUltcGxpY2l0Q29tbWEgPSB1bmRlZmluZWQgIT09IHN0YWNrVG9wXG4gICAgICA/IHRoaXMub2Zmc2lkZUNoZWNrSW1wbGljaXRDb21tYShzdGFja1RvcClcbiAgICAgIDogbnVsbFxuICBjYXRjaCBlcnIgOjpcbiAgICBpZiBlcnIgIT09IG9mZnNpZGVCcmVha291dCA6OiB0aHJvdyBlcnJcblxucHAub2Zmc2lkZUNoZWNrSW1wbGljaXRDb21tYSA9IGZ1bmN0aW9uKHN0YWNrVG9wKSA6OlxuICBpZiAhIHN0YWNrVG9wLm9wLmltcGxpY2l0Q29tbWFzIHx8ICEgdGhpcy5vZmZzaWRlUGx1Z2luT3B0cy5pbXBsaWNpdF9jb21tYXMgOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gbm90IGVuYWJsZWQgZm9yIHRoaXMgb2Zmc2lkZSBvcFxuXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSwgY29sdW1uID0gc3RhdGUucG9zIC0gc3RhdGUubGluZVN0YXJ0XG4gIGlmIGNvbHVtbiAhPT0gc3RhY2tUb3AuaW5uZXJJbmRlbnQubGVuZ3RoIDo6XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5vdCBhdCB0aGUgZXhhY3QgcmlnaHQgaW5kZW50XG4gIGlmIHN0YWNrVG9wLmVuZCA+PSBzdGF0ZS5lbmQgOjpcbiAgICByZXR1cm4gZmFsc2UgLy8gbm8gY29tbWEgYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50XG4gIGlmIHR0LmNvbW1hID09PSBzdGF0ZS50eXBlIDo6XG4gICAgcmV0dXJuIGZhbHNlIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgY29tbWEgYWxyZWFkeSBwcmVzZW50XG4gIGlmIHN0YXRlLnR5cGUuYmlub3AgfHwgc3RhdGUudHlwZS5iZWZvcmVFeHByIDo6XG4gICAgaWYgc3RhdGUudHlwZS5iZWZvcmVFeHByIDo6XG4gICAgICBjb25zb2xlLmxvZyBAICdiZWZvcmVFeHByJywgc3RhdGUudHlwZVxuICAgIHJldHVybiBmYWxzZSAvLyB0aGVyZSdzIGFuIG9wZXJhdG9yIHByZWNlZWRpbmcgdGhpcyBsaW5lXG5cbiAgaWYgdGhpcy5pc0xvb2thaGVhZCA6OiByZXR1cm4gZmFsc2UgLy8gZGlzYWxsb3cgcmVjdXJzaXZlIGxvb2thaGVhZFxuICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpXG4gIGlmIHR0LmNvbW1hID09PSBsb29rYWhlYWQudHlwZSA6OlxuICAgIHJldHVybiBmYWxzZSAvLyB0aGVyZSdzIGFuIGV4cGxpY2l0IGNvbW1hIHByZXNlbnQgaW4gdGhlIG5leHQgdG9rZW5cblxuICBjb25zb2xlLmxvZyBAICdHT1RJTUUnLCBzdGF0ZS50eXBlLCBzdGF0ZVxuICByZXR1cm4gdHJ1ZSAvLyBhIGNvbW1hIGlzIG5lZWRlZFxuXG5wcC5fYmFzZV9yZWFkVG9rZW4gPSBiYXNlUHJvdG8ucmVhZFRva2VuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcblxuICBpZiBzdGF0ZS5vZmZzaWRlSW1wbGljaXRDb21tYSA6OlxuICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR0LmNvbW1hKVxuXG4gIGNvbnN0IG9mZnNpZGVOZXh0T3AgPSBzdGF0ZS5vZmZzaWRlTmV4dE9wXG4gIGlmIG51bGwgIT09IG9mZnNpZGVOZXh0T3AgOjpcbiAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gbnVsbFxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9mZnNpZGVPcChvZmZzaWRlTmV4dE9wKVxuXG4gIGlmIHN0YXRlLnBvcyA9PT0gc3RhdGUub2Zmc2lkZVBvcyA6OlxuICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIHJldHVybiB0aGlzLl9iYXNlX3JlYWRUb2tlbihjb2RlKVxuXG5wcC5wb3BPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBjb25zdCBzdGFja1RvcCA9IHRoaXMuaXNMb29rYWhlYWRcbiAgICA/IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIDogc3RhY2sucG9wKClcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gLTFcblxuICB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHN0YWNrVG9wLm9wLnRva2VuUG9zdClcbiAgcmV0dXJuIHN0YWNrVG9wXG4iXX0=