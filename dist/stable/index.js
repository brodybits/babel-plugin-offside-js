const babylon = require('babylon');
const tt = babylon.tokTypes;

var _g_offsidePluginOpts;
const default_offsidePluginOpts = { check_blocks: true };

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  let tgt_patch = babylon.tokTypes.braceL;
  let fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = parseOffsideIndexMap(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      let offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

let tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

let tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

let at_offside = { '::': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, codeBlock: true },
  '::@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 1 },
  '::()': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 2 },
  '::{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, extraChars: 2 },
  '::[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: false, extraChars: 2 },
  '@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: true, keywordBlock: true },
  '@()': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: true, extraChars: 2 }
  // note:  no '@()' -- standardize to use single-char '@ ' instead
  , keyword_args: { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, inKeywordArg: true } };

pp.isForAwait = function (keywordType, type, val) {
  return tt._for === keywordType && tt.name === type && 'await' === val;
};

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  const recentKeyword = state.offsideRecentKeyword;
  let inForAwait = recentKeyword ? this.isForAwait(recentKeyword, type, val) : null;
  state.offsideRecentKeyword = null;

  if (tt_offside_keyword_with_args.has(type) || inForAwait) {
    let isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    state.offsideRecentKeyword = inForAwait ? tt._for : type;
    const lookahead = this.lookahead();

    if (tt_offside_keyword_lookahead_skip.has(lookahead.type)) {} else if (this.isForAwait(type, lookahead.type, lookahead.value)) {} else {
      state.offsideNextOp = at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const str_op = this.input.slice(pos0, pos1).split(/\s/, 1)[0];

    let op = at_offside[str_op];
    if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(recentKeyword)) {
      op = at_offside.keyword_args;
    }
    if (op) {
      return this.finishOffsideOp(op);
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideIndent = function (line0, outerIndent, innerIndent) {
  const offside_lines = this.offside_lines;

  if (null == innerIndent) {
    const innerLine = offside_lines[line0 + 1];
    innerIndent = innerLine ? innerLine.indent : '';
  }

  let line = line0 + 1,
      last = offside_lines[line0];
  while (line < offside_lines.length) {
    const cur = offside_lines[line];
    if (cur.content && outerIndent >= cur.indent) {
      line--; // backup to previous line
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  return { line, last, innerIndent };
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  let offside_lines = this.offside_lines;

  const line0 = this.state.curLine;
  const first = offside_lines[line0];

  let indent, keywordNestedIndent;
  if (recentKeywordTop) {
    indent = recentKeywordTop.first.indent;
  } else if (op.nestInner && stackTop && line0 === stackTop.first.line) {
    indent = stackTop.innerIndent;
  } else if (op.inKeywordArg) {
    indent = first.indent;
    const indent_block = this.offsideIndent(line0, indent);
    const indent_keyword = this.offsideIndent(line0, indent_block.innerIndent);
    if (indent_keyword.innerIndent > indent_block.innerIndent) {
      // autodetect keyword argument using '@' for function calls
      indent = indent_block.innerIndent;
      keywordNestedIndent = indent_keyword.innerIndent;
    }
  } else {
    indent = first.indent;
  }

  let { last, innerIndent } = this.offsideIndent(line0, indent, keywordNestedIndent);

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  return { op, innerIndent, first, last };
};

pp.finishOffsideOp = function (op) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (op.extraChars) {
    this.state.pos += op.extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  let blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  let stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};

const rx_offside = /^([ \t]*)(.*)$/mg;
function parseOffsideIndexMap(input) {
  let lines = [null],
      posLastContent = 0,
      last = ['', 0];

  let ans = input.replace(rx_offside, (match, indent, content, pos) => {
    if (!content) {
      [indent, posLastContent] = last; // blank line; use last valid content as end
    } else {
        // valid content; set last to current indent
        posLastContent = pos + match.length;
        last = [indent, posLastContent];
      }

    lines.push({ line: lines.length, posLastContent, indent, content });
    return '';
  });

  return lines;
}

const babel_plugin_id = `babel-plugin-offside--${Date.now()}`;
module.exports = exports = babel => {
  return {
    name: babel_plugin_id,
    pre(state) {
      this.opts = Object.assign({}, default_offsidePluginOpts, this.opts);
    }, post(state) {
      //console.dir @ state.ast.program, @{} colors: true, depth: null
    }, manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('asyncGenerators', 'classProperties', 'decorators', 'functionBind');
      const offsidePluginOpts = opts.plugins.filter(plugin => plugin[0] && babel_plugin_id === plugin[0].key && plugin[1]).map(plugin => plugin[1]).pop();
      parserOpts.offsidePluginOpts = offsidePluginOpts || default_offsidePluginOpts;
    }, visitor: {
      Program(path) {
        if (this.opts.check_blocks) {
          ensureConsistentBlockIndent(path);
        }
      }, BlockStatement(path) {
        if (this.opts.check_blocks) {
          ensureConsistentBlockIndent(path);
        }
      } } };
};

function ensureConsistentBlockIndent(path) {
  const body = path.node.body.filter(child => child.loc // synthetic children sometimes do not have locations
  );if (!body || !body.length) {
    return;
  }

  let prev_line;
  const block_column = body[0].loc.start.column;
  for (const child of body) {
    const start = child.loc.start;
    if (start.line != prev_line && start.column != block_column) {
      throw path.hub.file.buildCodeFrameError(child, `Indent mismatch. (block: ${block_column}, statement: ${start.column}). \n` + `    (From 'check_blocks' enforcement option of babel-plugin-offside)`);
    }

    prev_line = start.line;
  }
}

Object.assign(exports, {
  hookBabylon,
  parseOffsideIndexMap,
  ensureConsistentBlockIndent });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsiYmFieWxvbiIsInJlcXVpcmUiLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzIiwiY2hlY2tfYmxvY2tzIiwiX2Jhc2VfbW9kdWxlX3BhcnNlIiwicGFyc2UiLCJpbnB1dCIsIm9wdGlvbnMiLCJvZmZzaWRlUGx1Z2luT3B0cyIsInVuZGVmaW5lZCIsIlBhcnNlciIsImhvb2tCYWJ5bG9uIiwiYmFzZVByb3RvIiwicHJvdG90eXBlIiwicHAiLCJPYmplY3QiLCJjcmVhdGUiLCJ0Z3RfcGF0Y2giLCJicmFjZUwiLCJmbl91cGRhdGVDb250ZXh0IiwidXBkYXRlQ29udGV4dCIsInByZXZUeXBlIiwiY29uc3RydWN0b3IiLCJFcnJvciIsIl9iYXNlX3BhcnNlIiwiaW5pdE9mZnNpZGUiLCJPZmZzaWRlQnJlYWtvdXQiLCJvZmZzaWRlQnJlYWtvdXQiLCJzdGF0ZSIsIm9mZnNpZGUiLCJvZmZzaWRlTmV4dE9wIiwib2Zmc2lkZV9saW5lcyIsInBhcnNlT2Zmc2lkZUluZGV4TWFwIiwiX3BvcyIsInBvcyIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInNldCIsIm9mZlBvcyIsIm9mZnNpZGVQb3MiLCJ0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzIiwiU2V0IiwiX2lmIiwiX3doaWxlIiwiX2ZvciIsIl9jYXRjaCIsIl9zd2l0Y2giLCJ0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAiLCJwYXJlbkwiLCJjb2xvbiIsImNvbW1hIiwiZG90IiwiYXRfb2Zmc2lkZSIsInRva2VuUHJlIiwidG9rZW5Qb3N0IiwiYnJhY2VSIiwibmVzdElubmVyIiwiY29kZUJsb2NrIiwicGFyZW5SIiwiZXh0cmFDaGFycyIsImJyYWNrZXRMIiwiYnJhY2tldFIiLCJrZXl3b3JkQmxvY2siLCJrZXl3b3JkX2FyZ3MiLCJpbktleXdvcmRBcmciLCJpc0ZvckF3YWl0Iiwia2V5d29yZFR5cGUiLCJ0eXBlIiwidmFsIiwibmFtZSIsIl9iYXNlX2ZpbmlzaFRva2VuIiwiZmluaXNoVG9rZW4iLCJyZWNlbnRLZXl3b3JkIiwib2Zmc2lkZVJlY2VudEtleXdvcmQiLCJpbkZvckF3YWl0IiwiaGFzIiwiaXNLZXl3b3JkQWxsb3dlZCIsImlzTG9va2FoZWFkIiwibG9va2FoZWFkIiwidmFsdWUiLCJhdCIsImRvdWJsZUNvbG9uIiwicG9zMCIsInN0YXJ0IiwicG9zMSIsInN0cl9vcCIsInNsaWNlIiwic3BsaXQiLCJvcCIsImZpbmlzaE9mZnNpZGVPcCIsImVvZiIsImxlbmd0aCIsInBvcE9mZnNpZGUiLCJvZmZzaWRlSW5kZW50IiwibGluZTAiLCJvdXRlckluZGVudCIsImlubmVySW5kZW50IiwiaW5uZXJMaW5lIiwiaW5kZW50IiwibGluZSIsImxhc3QiLCJjdXIiLCJjb250ZW50Iiwib2Zmc2lkZUJsb2NrIiwic3RhY2tUb3AiLCJyZWNlbnRLZXl3b3JkVG9wIiwiY3VyTGluZSIsImZpcnN0Iiwia2V5d29yZE5lc3RlZEluZGVudCIsImluZGVudF9ibG9jayIsImluZGVudF9rZXl3b3JkIiwic3RhY2siLCJvZmZzaWRlUmVjZW50VG9wIiwiYmxrIiwicHVzaCIsIl9iYXNlX3NraXBTcGFjZSIsInNraXBTcGFjZSIsInBvc0xhc3RDb250ZW50IiwiZXJyIiwiX2Jhc2VfcmVhZFRva2VuIiwicmVhZFRva2VuIiwiY29kZSIsInBvcCIsInJ4X29mZnNpZGUiLCJsaW5lcyIsImFucyIsInJlcGxhY2UiLCJtYXRjaCIsImJhYmVsX3BsdWdpbl9pZCIsIkRhdGUiLCJub3ciLCJtb2R1bGUiLCJleHBvcnRzIiwiYmFiZWwiLCJwcmUiLCJvcHRzIiwiYXNzaWduIiwicG9zdCIsIm1hbmlwdWxhdGVPcHRpb25zIiwicGFyc2VyT3B0cyIsInBsdWdpbnMiLCJmaWx0ZXIiLCJwbHVnaW4iLCJrZXkiLCJtYXAiLCJ2aXNpdG9yIiwiUHJvZ3JhbSIsInBhdGgiLCJlbnN1cmVDb25zaXN0ZW50QmxvY2tJbmRlbnQiLCJCbG9ja1N0YXRlbWVudCIsImJvZHkiLCJub2RlIiwiY2hpbGQiLCJsb2MiLCJwcmV2X2xpbmUiLCJibG9ja19jb2x1bW4iLCJjb2x1bW4iLCJodWIiLCJmaWxlIiwiYnVpbGRDb2RlRnJhbWVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsVUFBVUMsUUFBUSxTQUFSLENBQWhCO0FBQ0EsTUFBTUMsS0FBS0YsUUFBUUcsUUFBbkI7O0FBRUEsSUFBSUMsb0JBQUo7QUFDQSxNQUFNQyw0QkFDSixFQUFJQyxjQUFjLElBQWxCLEVBREY7O0FBR0EsTUFBTUMscUJBQXFCUCxRQUFRUSxLQUFuQztBQUNBUixRQUFRUSxLQUFSLEdBQWdCLENBQUNDLEtBQUQsRUFBUUMsT0FBUixLQUFvQjtBQUNsQ04seUJBQXVCTSxVQUFVQSxRQUFRQyxpQkFBbEIsR0FBc0NDLFNBQTdEO0FBQ0EsU0FBT0wsbUJBQW1CRSxLQUFuQixFQUEwQkMsT0FBMUIsQ0FBUDtBQUF5QyxDQUYzQzs7QUFJQSxNQUFNRyxTQUFTQyxhQUFmO0FBQ0EsTUFBTUMsWUFBWUYsT0FBT0csU0FBekI7QUFDQSxNQUFNQyxLQUFLSixPQUFPRyxTQUFQLEdBQW1CRSxPQUFPQyxNQUFQLENBQWNKLFNBQWQsQ0FBOUI7O0FBRUEsU0FBU0QsV0FBVCxHQUF1QjtBQUNyQjtBQUNBOztBQUVBLE1BQUlELE1BQUo7QUFDQSxNQUFJTyxZQUFZcEIsUUFBUUcsUUFBUixDQUFpQmtCLE1BQWpDO0FBQ0EsTUFBSUMsbUJBQW1CRixVQUFVRyxhQUFqQztBQUNBSCxZQUFVRyxhQUFWLEdBQTBCLFVBQVVDLFFBQVYsRUFBb0I7QUFDNUNKLGNBQVVHLGFBQVYsR0FBMEJELGdCQUExQjtBQUNBVCxhQUFTLEtBQUtZLFdBQWQ7QUFBeUIsR0FGM0I7O0FBSUF6QixVQUFRUSxLQUFSLENBQWMsSUFBZDtBQUNBLE1BQUksQ0FBQ0ssTUFBTCxFQUFhO0FBQ1gsVUFBTSxJQUFJYSxLQUFKLENBQVks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QUFBaUM7QUFBQSxPQUx6RCxFQWZOLEVBQVA7QUFvQnNFLENBckJ4RTs7QUF1QkEsU0FBU0MsMkJBQVQsQ0FBcUNELElBQXJDLEVBQTJDO0FBQ3pDLFFBQU1HLE9BQU9ILEtBQUtJLElBQUwsQ0FBVUQsSUFBVixDQUNWVCxNQURVLENBQ0RXLFNBQVNBLE1BQU1DLEdBRGQsQ0FDa0I7QUFEbEIsR0FBYixDQUVBLElBQUcsQ0FBQ0gsSUFBRCxJQUFTLENBQUNBLEtBQUszRCxNQUFsQixFQUEyQjtBQUFDO0FBQU07O0FBRWxDLE1BQUkrRCxTQUFKO0FBQ0EsUUFBTUMsZUFBZUwsS0FBSyxDQUFMLEVBQVFHLEdBQVIsQ0FBWXRFLEtBQVosQ0FBa0J5RSxNQUF2QztBQUNBLE9BQUksTUFBTUosS0FBVixJQUFtQkYsSUFBbkIsRUFBMEI7QUFDeEIsVUFBTW5FLFFBQVFxRSxNQUFNQyxHQUFOLENBQVV0RSxLQUF4QjtBQUNBLFFBQUdBLE1BQU1nQixJQUFOLElBQWN1RCxTQUFkLElBQTJCdkUsTUFBTXlFLE1BQU4sSUFBZ0JELFlBQTlDLEVBQTZEO0FBQzNELFlBQU1SLEtBQUtVLEdBQUwsQ0FBU0MsSUFBVCxDQUFjQyxtQkFBZCxDQUFvQ1AsS0FBcEMsRUFDSCw0QkFBMkJHLFlBQWEsZ0JBQWV4RSxNQUFNeUUsTUFBTyxPQUFyRSxHQUNDLHNFQUZHLENBQU47QUFFd0U7O0FBRTFFRixnQkFBWXZFLE1BQU1nQixJQUFsQjtBQUFzQjtBQUFBOztBQUcxQnJGLE9BQU8wSCxNQUFQLENBQWdCSixPQUFoQixFQUNFO0FBQ0UxSCxhQURGO0FBRUVxQixzQkFGRjtBQUdFcUgsNkJBSEYsRUFERiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhYnlsb24gPSByZXF1aXJlKCdiYWJ5bG9uJylcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcbmNvbnN0IGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHMgPVxuICBAe30gY2hlY2tfYmxvY2tzOiB0cnVlXG5cbmNvbnN0IF9iYXNlX21vZHVsZV9wYXJzZSA9IGJhYnlsb24ucGFyc2VcbmJhYnlsb24ucGFyc2UgPSAoaW5wdXQsIG9wdGlvbnMpID0+IDo6XG4gIF9nX29mZnNpZGVQbHVnaW5PcHRzID0gb3B0aW9ucyA/IG9wdGlvbnMub2Zmc2lkZVBsdWdpbk9wdHMgOiB1bmRlZmluZWRcbiAgcmV0dXJuIF9iYXNlX21vZHVsZV9wYXJzZShpbnB1dCwgb3B0aW9ucylcblxuY29uc3QgUGFyc2VyID0gaG9va0JhYnlsb24oKVxuY29uc3QgYmFzZVByb3RvID0gUGFyc2VyLnByb3RvdHlwZVxuY29uc3QgcHAgPSBQYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvdG8pXG5cbmZ1bmN0aW9uIGhvb2tCYWJ5bG9uKCkgOjpcbiAgLy8gYWJ1c2UgQmFieWxvbiB0b2tlbiB1cGRhdGVDb250ZXh0IGNhbGxiYWNrIGV4dHJhY3RcbiAgLy8gdGhlIHJlZmVyZW5jZSB0byBQYXJzZXJcblxuICBsZXQgUGFyc2VyXG4gIGxldCB0Z3RfcGF0Y2ggPSBiYWJ5bG9uLnRva1R5cGVzLmJyYWNlTFxuICBsZXQgZm5fdXBkYXRlQ29udGV4dCA9IHRndF9wYXRjaC51cGRhdGVDb250ZXh0XG4gIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSA6OlxuICAgIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZm5fdXBkYXRlQ29udGV4dFxuICAgIFBhcnNlciA9IHRoaXMuY29uc3RydWN0b3JcblxuICBiYWJ5bG9uLnBhcnNlKCd7fScpXG4gIGlmICghUGFyc2VyKSA6OlxuICAgIHRocm93IG5ldyBFcnJvciBAIFwiRmFpbGVkIHRvIGhvb2sgQmFieWxvbiBQYXJzZXJcIlxuICByZXR1cm4gUGFyc2VyXG5cblxuXG5wcC5fYmFzZV9wYXJzZSA9IGJhc2VQcm90by5wYXJzZVxucHAucGFyc2UgPSBmdW5jdGlvbigpIDo6XG4gIHRoaXMuaW5pdE9mZnNpZGUoKVxuICByZXR1cm4gdGhpcy5fYmFzZV9wYXJzZSgpXG5cblxuY2xhc3MgT2Zmc2lkZUJyZWFrb3V0IGV4dGVuZHMgRXJyb3Ige31cbmNvbnN0IG9mZnNpZGVCcmVha291dCA9IG5ldyBPZmZzaWRlQnJlYWtvdXQoKVxuXG5wcC5pbml0T2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlID0gW11cbiAgdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wID0gbnVsbFxuICB0aGlzLm9mZnNpZGVfbGluZXMgPSBwYXJzZU9mZnNpZGVJbmRleE1hcCh0aGlzLmlucHV0KVxuICB0aGlzLm9mZnNpZGVQbHVnaW5PcHRzID0gX2dfb2Zmc2lkZVBsdWdpbk9wdHMgfHwge31cbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBudWxsXG5cbiAgdGhpcy5zdGF0ZS5fcG9zID0gdGhpcy5zdGF0ZS5wb3NcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5IEAgdGhpcy5zdGF0ZSwgJ3BvcycsXG4gICAgQHt9IGVudW1lcmFibGU6IHRydWVcbiAgICAgICwgZ2V0KCkgOjogcmV0dXJuIHRoaXMuX3Bvc1xuICAgICAgLCBzZXQocG9zKSA6OlxuICAgICAgICAgIC8vIGludGVycnVwdCBza2lwU3BhY2UgYWxnb3JpdGhtIHdoZW4gd2UgaGl0IG91ciBwb3NpdGlvbiAnYnJlYWtwb2ludCdcbiAgICAgICAgICBsZXQgb2ZmUG9zID0gdGhpcy5vZmZzaWRlUG9zXG4gICAgICAgICAgaWYgKG9mZlBvcz49MCAmJiAocG9zID4gb2ZmUG9zKSkgOjpcbiAgICAgICAgICAgIHRocm93IG9mZnNpZGVCcmVha291dFxuXG4gICAgICAgICAgdGhpcy5fcG9zID0gcG9zXG5cblxubGV0IHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MgPSBuZXcgU2V0IEBcbiAgQFtdIHR0Ll9pZiwgdHQuX3doaWxlLCB0dC5fZm9yXG4gICAgLCB0dC5fY2F0Y2gsIHR0Ll9zd2l0Y2hcblxubGV0IHR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCA9IG5ldyBTZXQgQFxuICBAW10gdHQucGFyZW5MLCB0dC5jb2xvbiwgdHQuY29tbWEsIHR0LmRvdFxuXG5sZXQgYXRfb2Zmc2lkZSA9XG4gIEB7fSAnOjonOiAgIHt0b2tlblByZTogdHQuYnJhY2VMLCB0b2tlblBvc3Q6IHR0LmJyYWNlUiwgbmVzdElubmVyOiBmYWxzZSwgY29kZUJsb2NrOiB0cnVlfVxuICAgICwgJzo6QCc6ICB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDF9XG4gICAgLCAnOjooKSc6IHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICc6Ont9Jzoge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJzo6W10nOiB7dG9rZW5QcmU6IHR0LmJyYWNrZXRMLCB0b2tlblBvc3Q6IHR0LmJyYWNrZXRSLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJ0AnOiAgICB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogdHJ1ZSwga2V5d29yZEJsb2NrOiB0cnVlfVxuICAgICwgJ0AoKSc6ICB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICdAe30nOiAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IHRydWUsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQFtdJzogIHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAvLyBub3RlOiAgbm8gJ0AoKScgLS0gc3RhbmRhcmRpemUgdG8gdXNlIHNpbmdsZS1jaGFyICdAICcgaW5zdGVhZFxuICAgICwga2V5d29yZF9hcmdzOiB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogZmFsc2UsIGluS2V5d29yZEFyZzogdHJ1ZX1cblxuXG5wcC5pc0ZvckF3YWl0ID0gZnVuY3Rpb24gKGtleXdvcmRUeXBlLCB0eXBlLCB2YWwpIDo6XG4gIHJldHVybiB0dC5fZm9yID09PSBrZXl3b3JkVHlwZVxuICAgICYmIHR0Lm5hbWUgPT09IHR5cGVcbiAgICAmJiAnYXdhaXQnID09PSB2YWxcblxucHAuX2Jhc2VfZmluaXNoVG9rZW4gPSBiYXNlUHJvdG8uZmluaXNoVG9rZW5cbnBwLmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgY29uc3QgcmVjZW50S2V5d29yZCA9IHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkXG4gIGxldCBpbkZvckF3YWl0ID0gcmVjZW50S2V5d29yZCA/IHRoaXMuaXNGb3JBd2FpdChyZWNlbnRLZXl3b3JkLCB0eXBlLCB2YWwpIDogbnVsbFxuICBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZCA9IG51bGxcblxuICBpZiB0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyh0eXBlKSB8fCBpbkZvckF3YWl0IDo6XG4gICAgbGV0IGlzS2V5d29yZEFsbG93ZWQgPSAhdGhpcy5pc0xvb2thaGVhZFxuICAgICAgJiYgdHQuZG90ICE9PSBzdGF0ZS50eXBlXG5cbiAgICBpZiAhaXNLZXl3b3JkQWxsb3dlZCA6OlxuICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4odHlwZSwgdmFsKVxuXG4gICAgc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmQgPSBpbkZvckF3YWl0ID8gdHQuX2ZvciA6IHR5cGVcbiAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpXG5cbiAgICBpZiB0dF9vZmZzaWRlX2tleXdvcmRfbG9va2FoZWFkX3NraXAuaGFzKGxvb2thaGVhZC50eXBlKSA6OlxuICAgIGVsc2UgaWYgdGhpcy5pc0ZvckF3YWl0KHR5cGUsIGxvb2thaGVhZC50eXBlLCBsb29rYWhlYWQudmFsdWUpIDo6XG4gICAgZWxzZSA6OlxuICAgICAgc3RhdGUub2Zmc2lkZU5leHRPcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG5cbiAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgaWYgdHlwZSA9PT0gdHQuYXQgfHwgdHlwZSA9PT0gdHQuZG91YmxlQ29sb24gOjpcbiAgICBjb25zdCBwb3MwID0gc3RhdGUuc3RhcnQsIHBvczEgPSBzdGF0ZS5wb3MgKyAyXG4gICAgY29uc3Qgc3RyX29wID0gdGhpcy5pbnB1dC5zbGljZShwb3MwLCBwb3MxKS5zcGxpdCgvXFxzLywgMSlbMF1cblxuICAgIGxldCBvcCA9IGF0X29mZnNpZGVbc3RyX29wXVxuICAgIGlmIG9wLmtleXdvcmRCbG9jayAmJiByZWNlbnRLZXl3b3JkICYmIHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MuaGFzKHJlY2VudEtleXdvcmQpIDo6XG4gICAgICBvcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG4gICAgaWYgb3AgOjogcmV0dXJuIHRoaXMuZmluaXNoT2Zmc2lkZU9wKG9wKVxuXG4gIGlmIHR0LmVvZiA9PT0gdHlwZSA6OlxuICAgIGlmIHN0YXRlLm9mZnNpZGUubGVuZ3RoIDo6XG4gICAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cblxucHAub2Zmc2lkZUluZGVudCA9IGZ1bmN0aW9uIChsaW5lMCwgb3V0ZXJJbmRlbnQsIGlubmVySW5kZW50KSA6OlxuICBjb25zdCBvZmZzaWRlX2xpbmVzID0gdGhpcy5vZmZzaWRlX2xpbmVzXG5cbiAgaWYgKG51bGwgPT0gaW5uZXJJbmRlbnQpIDo6XG4gICAgY29uc3QgaW5uZXJMaW5lID0gb2Zmc2lkZV9saW5lc1tsaW5lMCsxXVxuICAgIGlubmVySW5kZW50ID0gaW5uZXJMaW5lID8gaW5uZXJMaW5lLmluZGVudCA6ICcnXG5cbiAgbGV0IGxpbmU9bGluZTArMSwgbGFzdD1vZmZzaWRlX2xpbmVzW2xpbmUwXVxuICB3aGlsZSAobGluZSA8IG9mZnNpZGVfbGluZXMubGVuZ3RoKSA6OlxuICAgIGNvbnN0IGN1ciA9IG9mZnNpZGVfbGluZXNbbGluZV1cbiAgICBpZiAoY3VyLmNvbnRlbnQgJiYgb3V0ZXJJbmRlbnQgPj0gY3VyLmluZGVudCkgOjpcbiAgICAgIGxpbmUtLSAvLyBiYWNrdXAgdG8gcHJldmlvdXMgbGluZVxuICAgICAgYnJlYWtcblxuICAgIGxpbmUrKzsgbGFzdCA9IGN1clxuICAgIGlmIChpbm5lckluZGVudCA+IGN1ci5pbmRlbnQpIDo6XG4gICAgICBpbm5lckluZGVudCA9IGN1ci5pbmRlbnRcblxuICByZXR1cm4gQHt9IGxpbmUsIGxhc3QsIGlubmVySW5kZW50XG5cblxucHAub2Zmc2lkZUJsb2NrID0gZnVuY3Rpb24gKG9wLCBzdGFja1RvcCwgcmVjZW50S2V5d29yZFRvcCkgOjpcbiAgbGV0IG9mZnNpZGVfbGluZXMgPSB0aGlzLm9mZnNpZGVfbGluZXNcblxuICBjb25zdCBsaW5lMCA9IHRoaXMuc3RhdGUuY3VyTGluZVxuICBjb25zdCBmaXJzdCA9IG9mZnNpZGVfbGluZXNbbGluZTBdXG5cbiAgbGV0IGluZGVudCwga2V5d29yZE5lc3RlZEluZGVudFxuICBpZiAocmVjZW50S2V5d29yZFRvcCkgOjpcbiAgICBpbmRlbnQgPSByZWNlbnRLZXl3b3JkVG9wLmZpcnN0LmluZGVudFxuICBlbHNlIGlmIChvcC5uZXN0SW5uZXIgJiYgc3RhY2tUb3AgJiYgbGluZTAgPT09IHN0YWNrVG9wLmZpcnN0LmxpbmUpIDo6XG4gICAgaW5kZW50ID0gc3RhY2tUb3AuaW5uZXJJbmRlbnRcbiAgZWxzZSBpZiAob3AuaW5LZXl3b3JkQXJnKSA6OlxuICAgIGluZGVudCA9IGZpcnN0LmluZGVudFxuICAgIGNvbnN0IGluZGVudF9ibG9jayA9IHRoaXMub2Zmc2lkZUluZGVudChsaW5lMCwgaW5kZW50KVxuICAgIGNvbnN0IGluZGVudF9rZXl3b3JkID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQpXG4gICAgaWYgKGluZGVudF9rZXl3b3JkLmlubmVySW5kZW50ID4gaW5kZW50X2Jsb2NrLmlubmVySW5kZW50KSA6OlxuICAgICAgLy8gYXV0b2RldGVjdCBrZXl3b3JkIGFyZ3VtZW50IHVzaW5nICdAJyBmb3IgZnVuY3Rpb24gY2FsbHNcbiAgICAgIGluZGVudCA9IGluZGVudF9ibG9jay5pbm5lckluZGVudFxuICAgICAga2V5d29yZE5lc3RlZEluZGVudCA9IGluZGVudF9rZXl3b3JkLmlubmVySW5kZW50XG4gIGVsc2UgOjpcbiAgICBpbmRlbnQgPSBmaXJzdC5pbmRlbnRcblxuICBsZXQge2xhc3QsIGlubmVySW5kZW50fSA9IHRoaXMub2Zmc2lkZUluZGVudChsaW5lMCwgaW5kZW50LCBrZXl3b3JkTmVzdGVkSW5kZW50KVxuXG4gIC8vIGNhcCB0byBcbiAgaW5uZXJJbmRlbnQgPSBmaXJzdC5pbmRlbnQgPiBpbm5lckluZGVudFxuICAgID8gZmlyc3QuaW5kZW50IDogaW5uZXJJbmRlbnRcblxuICByZXR1cm4ge29wLCBpbm5lckluZGVudCwgZmlyc3QsIGxhc3R9XG5cblxuXG5wcC5maW5pc2hPZmZzaWRlT3AgPSBmdW5jdGlvbiAob3ApIDo6XG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gIGxldCByZWNlbnRLZXl3b3JkVG9wXG4gIGlmIChvcC5jb2RlQmxvY2spIDo6XG4gICAgaWYgKHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZykgOjpcbiAgICAgIHRoaXMucG9wT2Zmc2lkZSgpXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBvcFxuICAgICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gc3RhY2tUb3BcbiAgICAgIHJldHVyblxuXG4gICAgcmVjZW50S2V5d29yZFRvcCA9IHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcFxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcCA9IG51bGxcblxuICBpZiAob3AuZXh0cmFDaGFycykgOjpcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBvcC5leHRyYUNoYXJzXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihvcC50b2tlblByZSlcblxuICBpZiAodGhpcy5pc0xvb2thaGVhZCkgOjogcmV0dXJuXG5cbiAgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBsZXQgYmxrID0gdGhpcy5vZmZzaWRlQmxvY2sob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKVxuICBibGsuaW5LZXl3b3JkQXJnID0gb3AuaW5LZXl3b3JkQXJnIHx8IHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZ1xuICB0aGlzLnN0YXRlLm9mZnNpZGUucHVzaChibGspXG5cblxucHAuX2Jhc2Vfc2tpcFNwYWNlID0gYmFzZVByb3RvLnNraXBTcGFjZVxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSA6OlxuICBpZiAobnVsbCAhPT0gdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wKSA6OiByZXR1cm5cblxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3BcbiAgaWYgKHN0YWNrICYmIHN0YWNrLmxlbmd0aCkgOjpcbiAgICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IHN0YWNrVG9wLmxhc3QucG9zTGFzdENvbnRlbnRcbiAgZWxzZSA6OiB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gIHRyeSA6OlxuICAgIHRoaXMuX2Jhc2Vfc2tpcFNwYWNlKClcbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuICBjYXRjaCAoZXJyKSA6OlxuICAgIGlmIChlcnIgIT09IG9mZnNpZGVCcmVha291dCkgOjogdGhyb3cgZXJyXG5cblxucHAuX2Jhc2VfcmVhZFRva2VuID0gYmFzZVByb3RvLnJlYWRUb2tlblxucHAucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkgOjpcbiAgY29uc3Qgb2Zmc2lkZU5leHRPcCA9IHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcFxuICBpZiAobnVsbCAhPT0gb2Zmc2lkZU5leHRPcCkgOjpcbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT2Zmc2lkZU9wKG9mZnNpZGVOZXh0T3ApXG5cbiAgZWxzZSBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUub2Zmc2lkZVBvcykgOjpcbiAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICBlbHNlIDo6XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VfcmVhZFRva2VuKGNvZGUpXG5cbnBwLnBvcE9mZnNpZGUgPSBmdW5jdGlvbigpIDo6XG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcCA9IHRoaXMuaXNMb29rYWhlYWRcbiAgICA/IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIDogc3RhY2sucG9wKClcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gLTFcblxuICB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHN0YWNrVG9wLm9wLnRva2VuUG9zdClcbiAgcmV0dXJuIHN0YWNrVG9wXG5cblxuXG5jb25zdCByeF9vZmZzaWRlID0gL14oWyBcXHRdKikoLiopJC9tZ1xuZnVuY3Rpb24gcGFyc2VPZmZzaWRlSW5kZXhNYXAoaW5wdXQpIDo6XG4gIGxldCBsaW5lcyA9IFtudWxsXSwgcG9zTGFzdENvbnRlbnQ9MCwgbGFzdD1bJycsIDBdXG5cbiAgbGV0IGFucyA9IGlucHV0LnJlcGxhY2UgQCByeF9vZmZzaWRlLCAobWF0Y2gsIGluZGVudCwgY29udGVudCwgcG9zKSA9PiA6OlxuICAgIGlmICghY29udGVudCkgOjpcbiAgICAgIFtpbmRlbnQsIHBvc0xhc3RDb250ZW50XSA9IGxhc3QgLy8gYmxhbmsgbGluZTsgdXNlIGxhc3QgdmFsaWQgY29udGVudCBhcyBlbmRcbiAgICBlbHNlIDo6XG4gICAgICAvLyB2YWxpZCBjb250ZW50OyBzZXQgbGFzdCB0byBjdXJyZW50IGluZGVudFxuICAgICAgcG9zTGFzdENvbnRlbnQgPSBwb3MgKyBtYXRjaC5sZW5ndGhcbiAgICAgIGxhc3QgPSBbaW5kZW50LCBwb3NMYXN0Q29udGVudF1cblxuICAgIGxpbmVzLnB1c2goe2xpbmU6IGxpbmVzLmxlbmd0aCwgcG9zTGFzdENvbnRlbnQsIGluZGVudCwgY29udGVudH0pXG4gICAgcmV0dXJuICcnXG5cbiAgcmV0dXJuIGxpbmVzXG5cblxuY29uc3QgYmFiZWxfcGx1Z2luX2lkID0gYGJhYmVsLXBsdWdpbi1vZmZzaWRlLS0ke0RhdGUubm93KCl9YFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gKGJhYmVsKSA9PiA6OlxuICByZXR1cm4gOjpcbiAgICBuYW1lOiBiYWJlbF9wbHVnaW5faWRcbiAgICAsIHByZShzdGF0ZSkgOjpcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbiBAIHt9LCBkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzLCB0aGlzLm9wdHNcbiAgICAsIHBvc3Qoc3RhdGUpIDo6XG4gICAgICAgIC8vY29uc29sZS5kaXIgQCBzdGF0ZS5hc3QucHJvZ3JhbSwgQHt9IGNvbG9yczogdHJ1ZSwgZGVwdGg6IG51bGxcblxuICAgICwgbWFuaXB1bGF0ZU9wdGlvbnMob3B0cywgcGFyc2VyT3B0cykgOjpcbiAgICAgICAgcGFyc2VyT3B0cy5wbHVnaW5zLnB1c2goJ2FzeW5jR2VuZXJhdG9ycycsICdjbGFzc1Byb3BlcnRpZXMnLCAnZGVjb3JhdG9ycycsICdmdW5jdGlvbkJpbmQnKVxuICAgICAgICBjb25zdCBvZmZzaWRlUGx1Z2luT3B0cyA9IG9wdHMucGx1Z2luc1xuICAgICAgICAgIC5maWx0ZXIgQCBwbHVnaW4gPT4gcGx1Z2luWzBdICYmIGJhYmVsX3BsdWdpbl9pZCA9PT0gcGx1Z2luWzBdLmtleSAmJiBwbHVnaW5bMV1cbiAgICAgICAgICAubWFwIEAgcGx1Z2luID0+IHBsdWdpblsxXVxuICAgICAgICAgIC5wb3AoKVxuICAgICAgICBwYXJzZXJPcHRzLm9mZnNpZGVQbHVnaW5PcHRzID0gb2Zmc2lkZVBsdWdpbk9wdHMgfHwgZGVmYXVsdF9vZmZzaWRlUGx1Z2luT3B0c1xuXG4gICAgLCB2aXNpdG9yOiA6OlxuICAgICAgICBQcm9ncmFtKHBhdGgpIDo6XG4gICAgICAgICAgaWYgdGhpcy5vcHRzLmNoZWNrX2Jsb2NrcyA6OiBlbnN1cmVDb25zaXN0ZW50QmxvY2tJbmRlbnQocGF0aClcblxuICAgICAgLCBCbG9ja1N0YXRlbWVudChwYXRoKSA6OlxuICAgICAgICAgIGlmIHRoaXMub3B0cy5jaGVja19ibG9ja3MgOjogZW5zdXJlQ29uc2lzdGVudEJsb2NrSW5kZW50KHBhdGgpXG5cbmZ1bmN0aW9uIGVuc3VyZUNvbnNpc3RlbnRCbG9ja0luZGVudChwYXRoKSA6OlxuICBjb25zdCBib2R5ID0gcGF0aC5ub2RlLmJvZHlcbiAgICAuZmlsdGVyIEAgY2hpbGQgPT4gY2hpbGQubG9jIC8vIHN5bnRoZXRpYyBjaGlsZHJlbiBzb21ldGltZXMgZG8gbm90IGhhdmUgbG9jYXRpb25zXG4gIGlmICFib2R5IHx8ICFib2R5Lmxlbmd0aCA6OiByZXR1cm5cblxuICBsZXQgcHJldl9saW5lXG4gIGNvbnN0IGJsb2NrX2NvbHVtbiA9IGJvZHlbMF0ubG9jLnN0YXJ0LmNvbHVtblxuICBmb3IgY29uc3QgY2hpbGQgb2YgYm9keSA6OlxuICAgIGNvbnN0IHN0YXJ0ID0gY2hpbGQubG9jLnN0YXJ0XG4gICAgaWYgc3RhcnQubGluZSAhPSBwcmV2X2xpbmUgJiYgc3RhcnQuY29sdW1uICE9IGJsb2NrX2NvbHVtbiA6OlxuICAgICAgdGhyb3cgcGF0aC5odWIuZmlsZS5idWlsZENvZGVGcmFtZUVycm9yIEAgY2hpbGQsXG4gICAgICAgIGBJbmRlbnQgbWlzbWF0Y2guIChibG9jazogJHtibG9ja19jb2x1bW59LCBzdGF0ZW1lbnQ6ICR7c3RhcnQuY29sdW1ufSkuIFxcbmAgK1xuICAgICAgICBgICAgIChGcm9tICdjaGVja19ibG9ja3MnIGVuZm9yY2VtZW50IG9wdGlvbiBvZiBiYWJlbC1wbHVnaW4tb2Zmc2lkZSlgXG5cbiAgICBwcmV2X2xpbmUgPSBzdGFydC5saW5lXG5cblxuT2JqZWN0LmFzc2lnbiBAIGV4cG9ydHMsXG4gIEB7fVxuICAgIGhvb2tCYWJ5bG9uLFxuICAgIHBhcnNlT2Zmc2lkZUluZGV4TWFwLFxuICAgIGVuc3VyZUNvbnNpc3RlbnRCbG9ja0luZGVudCxcbiJdfQ==