const babylon = require('babylon');
const tt = babylon.tokTypes;

var _g_offsidePluginOpts;
const default_offsidePluginOpts = { keyword_blocks: true };

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  let tgt_patch = babylon.tokTypes.braceL;
  let fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = parseOffsideIndexMap(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      let offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

let tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

let tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

let at_offside = { '::': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, codeBlock: true },
  '::@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 1 },
  '::()': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 2 },
  '::{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, extraChars: 2 },
  '::[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: false, extraChars: 2 },
  '@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: true, keywordBlock: true },
  '@()': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: true, extraChars: 2 }
  // note:  no '@()' -- standardize to use single-char '@ ' instead
  , keyword_args: { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, inKeywordArg: true } };

pp.isForAwait = function (keywordType, type, val) {
  return tt._for === keywordType && tt.name === type && 'await' === val;
};

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  const recentKeyword = state.offsideRecentKeyword;
  let inForAwait = recentKeyword ? this.isForAwait(recentKeyword, type, val) : null;
  state.offsideRecentKeyword = null;

  if (tt_offside_keyword_with_args.has(type) || inForAwait) {
    let isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    state.offsideRecentKeyword = inForAwait ? tt._for : type;
    const lookahead = this.lookahead();

    if (tt_offside_keyword_lookahead_skip.has(lookahead.type)) {} else if (this.isForAwait(type, lookahead.type, lookahead.value)) {} else {
      state.offsideNextOp = at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const str_op = this.input.slice(pos0, pos1).split(/\s/, 1)[0];

    let op = at_offside[str_op];
    if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(recentKeyword)) {
      op = at_offside.keyword_args;
    }
    if (op) {
      return this.finishOffsideOp(op);
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideIndent = function (line0, outerIndent, innerIndent) {
  const offside_lines = this.offside_lines;

  if (null == innerIndent) {
    const innerLine = offside_lines[line0 + 1];
    innerIndent = innerLine ? innerLine.indent : '';
  }

  let line = line0 + 1,
      last = offside_lines[line0];
  while (line < offside_lines.length) {
    const cur = offside_lines[line];
    if (cur.content && outerIndent >= cur.indent) {
      line--; // backup to previous line
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  return { line, last, innerIndent };
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  let offside_lines = this.offside_lines;

  const line0 = this.state.curLine;
  const first = offside_lines[line0];

  let indent, keywordNestedIndent;
  if (recentKeywordTop) {
    indent = recentKeywordTop.first.indent;
  } else if (op.nestInner && stackTop && line0 === stackTop.first.line) {
    indent = stackTop.innerIndent;
  } else if (op.inKeywordArg) {
    indent = first.indent;
    const indent_block = this.offsideIndent(line0, indent);
    const indent_keyword = this.offsideIndent(line0, indent_block.innerIndent);
    if (indent_keyword.innerIndent > indent_block.innerIndent) {
      // autodetect keyword argument using '@' for function calls
      indent = indent_block.innerIndent;
      keywordNestedIndent = indent_keyword.innerIndent;
    }
  } else {
    indent = first.indent;
  }

  let { last, innerIndent } = this.offsideIndent(line0, indent, keywordNestedIndent);

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  return { op, innerIndent, first, last };
};

pp.finishOffsideOp = function (op) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (op.extraChars) {
    this.state.pos += op.extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  let blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  let stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};

const rx_offside = /^([ \t]*)(.*)$/mg;
function parseOffsideIndexMap(input) {
  let lines = [null],
      posLastContent = 0,
      last = ['', 0];

  let ans = input.replace(rx_offside, (match, indent, content, pos) => {
    if (!content) {
      [indent, posLastContent] = last; // blank line; use last valid content as end
    } else {
        // valid content; set last to current indent
        posLastContent = pos + match.length;
        last = [indent, posLastContent];
      }

    lines.push({ line: lines.length, posLastContent, indent, content });
    return '';
  });

  return lines;
}

const keyword_block_parents = { IfStatement: 'if',
  ForStatement: 'for',
  ForOfStatement: 'for',
  ForAwaitStatement: 'for-await',
  WhileStatement: 'while',
  DoWhileStatement: 'do-while' };
const lint_keyword_block_parents = new Set(Object.keys(keyword_block_parents));

const babel_plugin_id = `babel-plugin-offside--${Date.now()}`;
module.exports = exports = babel => {
  return {
    name: babel_plugin_id,
    pre(state) {
      this.opts = Object.assign({}, default_offsidePluginOpts, this.opts);
    }, manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('asyncGenerators', 'classProperties', 'decorators', 'functionBind');
      const offsidePluginOpts = opts.plugins.filter(plugin => plugin[0] && babel_plugin_id === plugin[0].key && plugin[1]).map(plugin => plugin[1]).pop();
      parserOpts.offsidePluginOpts = offsidePluginOpts || default_offsidePluginOpts;
    }, visitor: {
      ExpressionStatement(path) {
        if (!this.opts.keyword_blocks) {
          return;
        }
        if (!lint_keyword_block_parents.has(path.parent.type)) {
          return;
        }

        let keyword = keyword_block_parents[path.parent.type];
        if ('if' === keyword && path.node === path.parent.alternate) {
          keyword = 'else'; // fixup if/else combined parent condition
        }throw path.buildCodeFrameError(`Keyword '${keyword}' should be followed by a block statement using '::' or matching '{' / '}'. \n` + `    (From 'keyword_blocks' enforcement option of babel-plugin-offside)`);
      } } };
};

Object.assign(exports, {
  hookBabylon,
  parseOffsideIndexMap });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsiYmFieWxvbiIsInJlcXVpcmUiLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzIiwia2V5d29yZF9ibG9ja3MiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwicGFyc2VPZmZzaWRlSW5kZXhNYXAiLCJfcG9zIiwicG9zIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0Iiwib2ZmUG9zIiwib2Zmc2lkZVBvcyIsInR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MiLCJTZXQiLCJfaWYiLCJfd2hpbGUiLCJfZm9yIiwiX2NhdGNoIiwiX3N3aXRjaCIsInR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCIsInBhcmVuTCIsImNvbG9uIiwiY29tbWEiLCJkb3QiLCJhdF9vZmZzaWRlIiwidG9rZW5QcmUiLCJ0b2tlblBvc3QiLCJicmFjZVIiLCJuZXN0SW5uZXIiLCJjb2RlQmxvY2siLCJwYXJlblIiLCJleHRyYUNoYXJzIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImtleXdvcmRCbG9jayIsImtleXdvcmRfYXJncyIsImluS2V5d29yZEFyZyIsImlzRm9yQXdhaXQiLCJrZXl3b3JkVHlwZSIsInR5cGUiLCJ2YWwiLCJuYW1lIiwiX2Jhc2VfZmluaXNoVG9rZW4iLCJmaW5pc2hUb2tlbiIsInJlY2VudEtleXdvcmQiLCJvZmZzaWRlUmVjZW50S2V5d29yZCIsImluRm9yQXdhaXQiLCJoYXMiLCJpc0tleXdvcmRBbGxvd2VkIiwiaXNMb29rYWhlYWQiLCJsb29rYWhlYWQiLCJ2YWx1ZSIsImF0IiwiZG91YmxlQ29sb24iLCJwb3MwIiwic3RhcnQiLCJwb3MxIiwic3RyX29wIiwic2xpY2UiLCJzcGxpdCIsIm9wIiwiZmluaXNoT2Zmc2lkZU9wIiwiZW9mIiwibGVuZ3RoIiwicG9wT2Zmc2lkZSIsIm9mZnNpZGVJbmRlbnQiLCJsaW5lMCIsIm91dGVySW5kZW50IiwiaW5uZXJJbmRlbnQiLCJpbm5lckxpbmUiLCJpbmRlbnQiLCJsaW5lIiwibGFzdCIsImN1ciIsImNvbnRlbnQiLCJvZmZzaWRlQmxvY2siLCJzdGFja1RvcCIsInJlY2VudEtleXdvcmRUb3AiLCJjdXJMaW5lIiwiZmlyc3QiLCJrZXl3b3JkTmVzdGVkSW5kZW50IiwiaW5kZW50X2Jsb2NrIiwiaW5kZW50X2tleXdvcmQiLCJzdGFjayIsIm9mZnNpZGVSZWNlbnRUb3AiLCJibGsiLCJwdXNoIiwiX2Jhc2Vfc2tpcFNwYWNlIiwic2tpcFNwYWNlIiwicG9zTGFzdENvbnRlbnQiLCJlcnIiLCJfYmFzZV9yZWFkVG9rZW4iLCJyZWFkVG9rZW4iLCJjb2RlIiwicG9wIiwicnhfb2Zmc2lkZSIsImxpbmVzIiwiYW5zIiwicmVwbGFjZSIsIm1hdGNoIiwia2V5d29yZF9ibG9ja19wYXJlbnRzIiwiSWZTdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiLCJGb3JPZlN0YXRlbWVudCIsIkZvckF3YWl0U3RhdGVtZW50IiwiV2hpbGVTdGF0ZW1lbnQiLCJEb1doaWxlU3RhdGVtZW50IiwibGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMiLCJrZXlzIiwiYmFiZWxfcGx1Z2luX2lkIiwiRGF0ZSIsIm5vdyIsIm1vZHVsZSIsImV4cG9ydHMiLCJiYWJlbCIsInByZSIsIm9wdHMiLCJhc3NpZ24iLCJtYW5pcHVsYXRlT3B0aW9ucyIsInBhcnNlck9wdHMiLCJwbHVnaW5zIiwiZmlsdGVyIiwicGx1Z2luIiwia2V5IiwibWFwIiwidmlzaXRvciIsIkV4cHJlc3Npb25TdGF0ZW1lbnQiLCJwYXRoIiwicGFyZW50Iiwia2V5d29yZCIsIm5vZGUiLCJhbHRlcm5hdGUiLCJidWlsZENvZGVGcmFtZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxVQUFVQyxRQUFRLFNBQVIsQ0FBaEI7QUFDQSxNQUFNQyxLQUFLRixRQUFRRyxRQUFuQjs7QUFFQSxJQUFJQyxvQkFBSjtBQUNBLE1BQU1DLDRCQUNKLEVBQUlDLGdCQUFnQixJQUFwQixFQURGOztBQUdBLE1BQU1DLHFCQUFxQlAsUUFBUVEsS0FBbkM7QUFDQVIsUUFBUVEsS0FBUixHQUFnQixDQUFDQyxLQUFELEVBQVFDLE9BQVIsS0FBb0I7QUFDbENOLHlCQUF1Qk0sVUFBVUEsUUFBUUMsaUJBQWxCLEdBQXNDQyxTQUE3RDtBQUNBLFNBQU9MLG1CQUFtQkUsS0FBbkIsRUFBMEJDLE9BQTFCLENBQVA7QUFBeUMsQ0FGM0M7O0FBSUEsTUFBTUcsU0FBU0MsYUFBZjtBQUNBLE1BQU1DLFlBQVlGLE9BQU9HLFNBQXpCO0FBQ0EsTUFBTUMsS0FBS0osT0FBT0csU0FBUCxHQUFtQkUsT0FBT0MsTUFBUCxDQUFjSixTQUFkLENBQTlCOztBQUVBLFNBQVNELFdBQVQsR0FBdUI7QUFDckI7QUFDQTs7QUFFQSxNQUFJRCxNQUFKO0FBQ0EsTUFBSU8sWUFBWXBCLFFBQVFHLFFBQVIsQ0FBaUJrQixNQUFqQztBQUNBLE1BQUlDLG1CQUFtQkYsVUFBVUcsYUFBakM7QUFDQUgsWUFBVUcsYUFBVixHQUEwQixVQUFVQyxRQUFWLEVBQW9CO0FBQzVDSixjQUFVRyxhQUFWLEdBQTBCRCxnQkFBMUI7QUFDQVQsYUFBUyxLQUFLWSxXQUFkO0FBQXlCLEdBRjNC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QXlCLGlCQUFXNUksaUJBQVgsR0FBK0JBLHFCQUFxQk4seUJBQXBEO0FBQTZFLEtBWDVFLEVBYUh3SixTQUFTO0FBQ1BDLDBCQUFvQkMsSUFBcEIsRUFBMEI7QUFDeEIsWUFBSSxDQUFDLEtBQUtYLElBQUwsQ0FBVTlJLGNBQWYsRUFBK0I7QUFBRztBQUFNO0FBQ3hDLFlBQUksQ0FBQ3FJLDJCQUEyQjVELEdBQTNCLENBQStCZ0YsS0FBS0MsTUFBTCxDQUFZekYsSUFBM0MsQ0FBTCxFQUF1RDtBQUFHO0FBQU07O0FBRWhFLFlBQUkwRixVQUFVN0Isc0JBQXNCMkIsS0FBS0MsTUFBTCxDQUFZekYsSUFBbEMsQ0FBZDtBQUNBLFlBQUksU0FBUzBGLE9BQVQsSUFBb0JGLEtBQUtHLElBQUwsS0FBY0gsS0FBS0MsTUFBTCxDQUFZRyxTQUFsRCxFQUE2RDtBQUMzREYsb0JBQVUsTUFBVixDQUQyRCxDQUMxQztBQUEwQyxTQUU3RCxNQUFNRixLQUFLSyxtQkFBTCxDQUNILFlBQVdILE9BQVEsZ0ZBQXBCLEdBQ0Msd0VBRkcsQ0FBTjtBQUUwRSxPQVhyRSxFQWJOLEVBQVA7QUF3QmtGLENBekJwRjs7QUE0QkEvSSxPQUFPbUksTUFBUCxDQUFnQkosT0FBaEIsRUFDRTtBQUNFbkksYUFERjtBQUVFcUIsc0JBRkYsRUFERiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhYnlsb24gPSByZXF1aXJlKCdiYWJ5bG9uJylcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcbmNvbnN0IGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHMgPVxuICBAe30ga2V5d29yZF9ibG9ja3M6IHRydWVcblxuY29uc3QgX2Jhc2VfbW9kdWxlX3BhcnNlID0gYmFieWxvbi5wYXJzZVxuYmFieWxvbi5wYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gOjpcbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBvcHRpb25zID8gb3B0aW9ucy5vZmZzaWRlUGx1Z2luT3B0cyA6IHVuZGVmaW5lZFxuICByZXR1cm4gX2Jhc2VfbW9kdWxlX3BhcnNlKGlucHV0LCBvcHRpb25zKVxuXG5jb25zdCBQYXJzZXIgPSBob29rQmFieWxvbigpXG5jb25zdCBiYXNlUHJvdG8gPSBQYXJzZXIucHJvdG90eXBlXG5jb25zdCBwcCA9IFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90bylcblxuZnVuY3Rpb24gaG9va0JhYnlsb24oKSA6OlxuICAvLyBhYnVzZSBCYWJ5bG9uIHRva2VuIHVwZGF0ZUNvbnRleHQgY2FsbGJhY2sgZXh0cmFjdFxuICAvLyB0aGUgcmVmZXJlbmNlIHRvIFBhcnNlclxuXG4gIGxldCBQYXJzZXJcbiAgbGV0IHRndF9wYXRjaCA9IGJhYnlsb24udG9rVHlwZXMuYnJhY2VMXG4gIGxldCBmbl91cGRhdGVDb250ZXh0ID0gdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHRcbiAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIDo6XG4gICAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmbl91cGRhdGVDb250ZXh0XG4gICAgUGFyc2VyID0gdGhpcy5jb25zdHJ1Y3RvclxuXG4gIGJhYnlsb24ucGFyc2UoJ3t9JylcbiAgaWYgKCFQYXJzZXIpIDo6XG4gICAgdGhyb3cgbmV3IEVycm9yIEAgXCJGYWlsZWQgdG8gaG9vayBCYWJ5bG9uIFBhcnNlclwiXG4gIHJldHVybiBQYXJzZXJcblxuXG5cbnBwLl9iYXNlX3BhcnNlID0gYmFzZVByb3RvLnBhcnNlXG5wcC5wYXJzZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5pbml0T2Zmc2lkZSgpXG4gIHJldHVybiB0aGlzLl9iYXNlX3BhcnNlKClcblxuXG5jbGFzcyBPZmZzaWRlQnJlYWtvdXQgZXh0ZW5kcyBFcnJvciB7fVxuY29uc3Qgb2Zmc2lkZUJyZWFrb3V0ID0gbmV3IE9mZnNpZGVCcmVha291dCgpXG5cbnBwLmluaXRPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICB0aGlzLnN0YXRlLm9mZnNpZGUgPSBbXVxuICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gIHRoaXMub2Zmc2lkZV9saW5lcyA9IHBhcnNlT2Zmc2lkZUluZGV4TWFwKHRoaXMuaW5wdXQpXG4gIHRoaXMub2Zmc2lkZVBsdWdpbk9wdHMgPSBfZ19vZmZzaWRlUGx1Z2luT3B0cyB8fCB7fVxuICBfZ19vZmZzaWRlUGx1Z2luT3B0cyA9IG51bGxcblxuICB0aGlzLnN0YXRlLl9wb3MgPSB0aGlzLnN0YXRlLnBvc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgQCB0aGlzLnN0YXRlLCAncG9zJyxcbiAgICBAe30gZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgLCBnZXQoKSA6OiByZXR1cm4gdGhpcy5fcG9zXG4gICAgICAsIHNldChwb3MpIDo6XG4gICAgICAgICAgLy8gaW50ZXJydXB0IHNraXBTcGFjZSBhbGdvcml0aG0gd2hlbiB3ZSBoaXQgb3VyIHBvc2l0aW9uICdicmVha3BvaW50J1xuICAgICAgICAgIGxldCBvZmZQb3MgPSB0aGlzLm9mZnNpZGVQb3NcbiAgICAgICAgICBpZiAob2ZmUG9zPj0wICYmIChwb3MgPiBvZmZQb3MpKSA6OlxuICAgICAgICAgICAgdGhyb3cgb2Zmc2lkZUJyZWFrb3V0XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBwb3NcblxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncyA9IG5ldyBTZXQgQFxuICBAW10gdHQuX2lmLCB0dC5fd2hpbGUsIHR0Ll9mb3JcbiAgICAsIHR0Ll9jYXRjaCwgdHQuX3N3aXRjaFxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwID0gbmV3IFNldCBAXG4gIEBbXSB0dC5wYXJlbkwsIHR0LmNvbG9uLCB0dC5jb21tYSwgdHQuZG90XG5cbmxldCBhdF9vZmZzaWRlID1cbiAgQHt9ICc6Oic6ICAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IGZhbHNlLCBjb2RlQmxvY2s6IHRydWV9XG4gICAgLCAnOjpAJzogIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgZXh0cmFDaGFyczogMX1cbiAgICAsICc6OigpJzoge3Rva2VuUHJlOiB0dC5wYXJlbkwsIHRva2VuUG9zdDogdHQucGFyZW5SLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJzo6e30nOiB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnOjpbXSc6IHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQCc6ICAgIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiB0cnVlLCBrZXl3b3JkQmxvY2s6IHRydWV9XG4gICAgLCAnQCgpJzogIHt0b2tlblByZTogdHQuYnJhY2VMLCB0b2tlblBvc3Q6IHR0LmJyYWNlUiwgbmVzdElubmVyOiB0cnVlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJ0B7fSc6ICB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICdAW10nOiAge3Rva2VuUHJlOiB0dC5icmFja2V0TCwgdG9rZW5Qb3N0OiB0dC5icmFja2V0UiwgbmVzdElubmVyOiB0cnVlLCBleHRyYUNoYXJzOiAyfVxuICAgIC8vIG5vdGU6ICBubyAnQCgpJyAtLSBzdGFuZGFyZGl6ZSB0byB1c2Ugc2luZ2xlLWNoYXIgJ0AgJyBpbnN0ZWFkXG4gICAgLCBrZXl3b3JkX2FyZ3M6IHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgaW5LZXl3b3JkQXJnOiB0cnVlfVxuXG5cbnBwLmlzRm9yQXdhaXQgPSBmdW5jdGlvbiAoa2V5d29yZFR5cGUsIHR5cGUsIHZhbCkgOjpcbiAgcmV0dXJuIHR0Ll9mb3IgPT09IGtleXdvcmRUeXBlXG4gICAgJiYgdHQubmFtZSA9PT0gdHlwZVxuICAgICYmICdhd2FpdCcgPT09IHZhbFxuXG5wcC5fYmFzZV9maW5pc2hUb2tlbiA9IGJhc2VQcm90by5maW5pc2hUb2tlblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIDo6XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVxuICBjb25zdCByZWNlbnRLZXl3b3JkID0gc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmRcbiAgbGV0IGluRm9yQXdhaXQgPSByZWNlbnRLZXl3b3JkID8gdGhpcy5pc0ZvckF3YWl0KHJlY2VudEtleXdvcmQsIHR5cGUsIHZhbCkgOiBudWxsXG4gIHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkID0gbnVsbFxuXG4gIGlmIHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MuaGFzKHR5cGUpIHx8IGluRm9yQXdhaXQgOjpcbiAgICBsZXQgaXNLZXl3b3JkQWxsb3dlZCA9ICF0aGlzLmlzTG9va2FoZWFkXG4gICAgICAmJiB0dC5kb3QgIT09IHN0YXRlLnR5cGVcblxuICAgIGlmICFpc0tleXdvcmRBbGxvd2VkIDo6XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgICBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZCA9IGluRm9yQXdhaXQgPyB0dC5fZm9yIDogdHlwZVxuICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKClcblxuICAgIGlmIHR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcC5oYXMobG9va2FoZWFkLnR5cGUpIDo6XG4gICAgZWxzZSBpZiB0aGlzLmlzRm9yQXdhaXQodHlwZSwgbG9va2FoZWFkLnR5cGUsIGxvb2thaGVhZC52YWx1ZSkgOjpcbiAgICBlbHNlIDo6XG4gICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcblxuICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICBpZiB0eXBlID09PSB0dC5hdCB8fCB0eXBlID09PSB0dC5kb3VibGVDb2xvbiA6OlxuICAgIGNvbnN0IHBvczAgPSBzdGF0ZS5zdGFydCwgcG9zMSA9IHN0YXRlLnBvcyArIDJcbiAgICBjb25zdCBzdHJfb3AgPSB0aGlzLmlucHV0LnNsaWNlKHBvczAsIHBvczEpLnNwbGl0KC9cXHMvLCAxKVswXVxuXG4gICAgbGV0IG9wID0gYXRfb2Zmc2lkZVtzdHJfb3BdXG4gICAgaWYgb3Aua2V5d29yZEJsb2NrICYmIHJlY2VudEtleXdvcmQgJiYgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncy5oYXMocmVjZW50S2V5d29yZCkgOjpcbiAgICAgIG9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcbiAgICBpZiBvcCA6OiByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob3ApXG5cbiAgaWYgdHQuZW9mID09PSB0eXBlIDo6XG4gICAgaWYgc3RhdGUub2Zmc2lkZS5sZW5ndGggOjpcbiAgICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuXG5wcC5vZmZzaWRlSW5kZW50ID0gZnVuY3Rpb24gKGxpbmUwLCBvdXRlckluZGVudCwgaW5uZXJJbmRlbnQpIDo6XG4gIGNvbnN0IG9mZnNpZGVfbGluZXMgPSB0aGlzLm9mZnNpZGVfbGluZXNcblxuICBpZiAobnVsbCA9PSBpbm5lckluZGVudCkgOjpcbiAgICBjb25zdCBpbm5lckxpbmUgPSBvZmZzaWRlX2xpbmVzW2xpbmUwKzFdXG4gICAgaW5uZXJJbmRlbnQgPSBpbm5lckxpbmUgPyBpbm5lckxpbmUuaW5kZW50IDogJydcblxuICBsZXQgbGluZT1saW5lMCsxLCBsYXN0PW9mZnNpZGVfbGluZXNbbGluZTBdXG4gIHdoaWxlIChsaW5lIDwgb2Zmc2lkZV9saW5lcy5sZW5ndGgpIDo6XG4gICAgY29uc3QgY3VyID0gb2Zmc2lkZV9saW5lc1tsaW5lXVxuICAgIGlmIChjdXIuY29udGVudCAmJiBvdXRlckluZGVudCA+PSBjdXIuaW5kZW50KSA6OlxuICAgICAgbGluZS0tIC8vIGJhY2t1cCB0byBwcmV2aW91cyBsaW5lXG4gICAgICBicmVha1xuXG4gICAgbGluZSsrOyBsYXN0ID0gY3VyXG4gICAgaWYgKGlubmVySW5kZW50ID4gY3VyLmluZGVudCkgOjpcbiAgICAgIGlubmVySW5kZW50ID0gY3VyLmluZGVudFxuXG4gIHJldHVybiBAe30gbGluZSwgbGFzdCwgaW5uZXJJbmRlbnRcblxuXG5wcC5vZmZzaWRlQmxvY2sgPSBmdW5jdGlvbiAob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKSA6OlxuICBsZXQgb2Zmc2lkZV9saW5lcyA9IHRoaXMub2Zmc2lkZV9saW5lc1xuXG4gIGNvbnN0IGxpbmUwID0gdGhpcy5zdGF0ZS5jdXJMaW5lXG4gIGNvbnN0IGZpcnN0ID0gb2Zmc2lkZV9saW5lc1tsaW5lMF1cblxuICBsZXQgaW5kZW50LCBrZXl3b3JkTmVzdGVkSW5kZW50XG4gIGlmIChyZWNlbnRLZXl3b3JkVG9wKSA6OlxuICAgIGluZGVudCA9IHJlY2VudEtleXdvcmRUb3AuZmlyc3QuaW5kZW50XG4gIGVsc2UgaWYgKG9wLm5lc3RJbm5lciAmJiBzdGFja1RvcCAmJiBsaW5lMCA9PT0gc3RhY2tUb3AuZmlyc3QubGluZSkgOjpcbiAgICBpbmRlbnQgPSBzdGFja1RvcC5pbm5lckluZGVudFxuICBlbHNlIGlmIChvcC5pbktleXdvcmRBcmcpIDo6XG4gICAgaW5kZW50ID0gZmlyc3QuaW5kZW50XG4gICAgY29uc3QgaW5kZW50X2Jsb2NrID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnQpXG4gICAgY29uc3QgaW5kZW50X2tleXdvcmQgPSB0aGlzLm9mZnNpZGVJbmRlbnQobGluZTAsIGluZGVudF9ibG9jay5pbm5lckluZGVudClcbiAgICBpZiAoaW5kZW50X2tleXdvcmQuaW5uZXJJbmRlbnQgPiBpbmRlbnRfYmxvY2suaW5uZXJJbmRlbnQpIDo6XG4gICAgICAvLyBhdXRvZGV0ZWN0IGtleXdvcmQgYXJndW1lbnQgdXNpbmcgJ0AnIGZvciBmdW5jdGlvbiBjYWxsc1xuICAgICAgaW5kZW50ID0gaW5kZW50X2Jsb2NrLmlubmVySW5kZW50XG4gICAgICBrZXl3b3JkTmVzdGVkSW5kZW50ID0gaW5kZW50X2tleXdvcmQuaW5uZXJJbmRlbnRcbiAgZWxzZSA6OlxuICAgIGluZGVudCA9IGZpcnN0LmluZGVudFxuXG4gIGxldCB7bGFzdCwgaW5uZXJJbmRlbnR9ID0gdGhpcy5vZmZzaWRlSW5kZW50KGxpbmUwLCBpbmRlbnQsIGtleXdvcmROZXN0ZWRJbmRlbnQpXG5cbiAgLy8gY2FwIHRvIFxuICBpbm5lckluZGVudCA9IGZpcnN0LmluZGVudCA+IGlubmVySW5kZW50XG4gICAgPyBmaXJzdC5pbmRlbnQgOiBpbm5lckluZGVudFxuXG4gIHJldHVybiB7b3AsIGlubmVySW5kZW50LCBmaXJzdCwgbGFzdH1cblxuXG5cbnBwLmZpbmlzaE9mZnNpZGVPcCA9IGZ1bmN0aW9uIChvcCkgOjpcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgbGV0IHJlY2VudEtleXdvcmRUb3BcbiAgaWYgKG9wLmNvZGVCbG9jaykgOjpcbiAgICBpZiAoc3RhY2tUb3AgJiYgc3RhY2tUb3AuaW5LZXl3b3JkQXJnKSA6OlxuICAgICAgdGhpcy5wb3BPZmZzaWRlKClcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG9wXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVSZWNlbnRUb3AgPSBzdGFja1RvcFxuICAgICAgcmV0dXJuXG5cbiAgICByZWNlbnRLZXl3b3JkVG9wID0gdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gbnVsbFxuXG4gIGlmIChvcC5leHRyYUNoYXJzKSA6OlxuICAgIHRoaXMuc3RhdGUucG9zICs9IG9wLmV4dHJhQ2hhcnNcblxuICB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKG9wLnRva2VuUHJlKVxuXG4gIGlmICh0aGlzLmlzTG9va2FoZWFkKSA6OiByZXR1cm5cblxuICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gIGxldCBibGsgPSB0aGlzLm9mZnNpZGVCbG9jayhvcCwgc3RhY2tUb3AsIHJlY2VudEtleXdvcmRUb3ApXG4gIGJsay5pbktleXdvcmRBcmcgPSBvcC5pbktleXdvcmRBcmcgfHwgc3RhY2tUb3AgJiYgc3RhY2tUb3AuaW5LZXl3b3JkQXJnXG4gIHRoaXMuc3RhdGUub2Zmc2lkZS5wdXNoKGJsaylcblxuXG5wcC5fYmFzZV9za2lwU3BhY2UgPSBiYXNlUHJvdG8uc2tpcFNwYWNlXG5wcC5za2lwU3BhY2UgPSBmdW5jdGlvbigpIDo6XG4gIGlmIChudWxsICE9PSB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3ApIDo6IHJldHVyblxuXG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcFxuICBpZiAoc3RhY2sgJiYgc3RhY2subGVuZ3RoKSA6OlxuICAgIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gc3RhY2tUb3AubGFzdC5wb3NMYXN0Q29udGVudFxuICBlbHNlIDo6IHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdHJ5IDo6XG4gICAgdGhpcy5fYmFzZV9za2lwU3BhY2UoKVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG4gIGNhdGNoIChlcnIpIDo6XG4gICAgaWYgKGVyciAhPT0gb2Zmc2lkZUJyZWFrb3V0KSA6OiB0aHJvdyBlcnJcblxuXG5wcC5fYmFzZV9yZWFkVG9rZW4gPSBiYXNlUHJvdG8ucmVhZFRva2VuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSA6OlxuICBjb25zdCBvZmZzaWRlTmV4dE9wID0gdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wXG4gIGlmIChudWxsICE9PSBvZmZzaWRlTmV4dE9wKSA6OlxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG51bGxcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob2Zmc2lkZU5leHRPcClcblxuICBlbHNlIGlmICh0aGlzLnN0YXRlLnBvcyA9PT0gdGhpcy5zdGF0ZS5vZmZzaWRlUG9zKSA6OlxuICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIGVsc2UgOjpcbiAgICByZXR1cm4gdGhpcy5fYmFzZV9yZWFkVG9rZW4oY29kZSlcblxucHAucG9wT2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wID0gdGhpcy5pc0xvb2thaGVhZFxuICAgID8gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgOiBzdGFjay5wb3AoKVxuICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4oc3RhY2tUb3Aub3AudG9rZW5Qb3N0KVxuICByZXR1cm4gc3RhY2tUb3BcblxuXG5cbmNvbnN0IHJ4X29mZnNpZGUgPSAvXihbIFxcdF0qKSguKikkL21nXG5mdW5jdGlvbiBwYXJzZU9mZnNpZGVJbmRleE1hcChpbnB1dCkgOjpcbiAgbGV0IGxpbmVzID0gW251bGxdLCBwb3NMYXN0Q29udGVudD0wLCBsYXN0PVsnJywgMF1cblxuICBsZXQgYW5zID0gaW5wdXQucmVwbGFjZSBAIHJ4X29mZnNpZGUsIChtYXRjaCwgaW5kZW50LCBjb250ZW50LCBwb3MpID0+IDo6XG4gICAgaWYgKCFjb250ZW50KSA6OlxuICAgICAgW2luZGVudCwgcG9zTGFzdENvbnRlbnRdID0gbGFzdCAvLyBibGFuayBsaW5lOyB1c2UgbGFzdCB2YWxpZCBjb250ZW50IGFzIGVuZFxuICAgIGVsc2UgOjpcbiAgICAgIC8vIHZhbGlkIGNvbnRlbnQ7IHNldCBsYXN0IHRvIGN1cnJlbnQgaW5kZW50XG4gICAgICBwb3NMYXN0Q29udGVudCA9IHBvcyArIG1hdGNoLmxlbmd0aFxuICAgICAgbGFzdCA9IFtpbmRlbnQsIHBvc0xhc3RDb250ZW50XVxuXG4gICAgbGluZXMucHVzaCh7bGluZTogbGluZXMubGVuZ3RoLCBwb3NMYXN0Q29udGVudCwgaW5kZW50LCBjb250ZW50fSlcbiAgICByZXR1cm4gJydcblxuICByZXR1cm4gbGluZXNcblxuXG5jb25zdCBrZXl3b3JkX2Jsb2NrX3BhcmVudHMgPVxuIEB7fSBJZlN0YXRlbWVudDogJ2lmJ1xuICAgLCBGb3JTdGF0ZW1lbnQ6ICdmb3InXG4gICAsIEZvck9mU3RhdGVtZW50OiAnZm9yJ1xuICAgLCBGb3JBd2FpdFN0YXRlbWVudDogJ2Zvci1hd2FpdCdcbiAgICwgV2hpbGVTdGF0ZW1lbnQ6ICd3aGlsZSdcbiAgICwgRG9XaGlsZVN0YXRlbWVudDogJ2RvLXdoaWxlJ1xuY29uc3QgbGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMgPSBuZXcgU2V0IEAgT2JqZWN0LmtleXMgQCBrZXl3b3JkX2Jsb2NrX3BhcmVudHNcblxuY29uc3QgYmFiZWxfcGx1Z2luX2lkID0gYGJhYmVsLXBsdWdpbi1vZmZzaWRlLS0ke0RhdGUubm93KCl9YFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gKGJhYmVsKSA9PiA6OlxuICByZXR1cm4gOjpcbiAgICBuYW1lOiBiYWJlbF9wbHVnaW5faWRcbiAgICAsIHByZShzdGF0ZSkgOjpcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbiBAIHt9LCBkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzLCB0aGlzLm9wdHNcblxuICAgICwgbWFuaXB1bGF0ZU9wdGlvbnMob3B0cywgcGFyc2VyT3B0cykgOjpcbiAgICAgICAgcGFyc2VyT3B0cy5wbHVnaW5zLnB1c2goJ2FzeW5jR2VuZXJhdG9ycycsICdjbGFzc1Byb3BlcnRpZXMnLCAnZGVjb3JhdG9ycycsICdmdW5jdGlvbkJpbmQnKVxuICAgICAgICBjb25zdCBvZmZzaWRlUGx1Z2luT3B0cyA9IG9wdHMucGx1Z2luc1xuICAgICAgICAgIC5maWx0ZXIgQCBwbHVnaW4gPT4gcGx1Z2luWzBdICYmIGJhYmVsX3BsdWdpbl9pZCA9PT0gcGx1Z2luWzBdLmtleSAmJiBwbHVnaW5bMV1cbiAgICAgICAgICAubWFwIEAgcGx1Z2luID0+IHBsdWdpblsxXVxuICAgICAgICAgIC5wb3AoKVxuICAgICAgICBwYXJzZXJPcHRzLm9mZnNpZGVQbHVnaW5PcHRzID0gb2Zmc2lkZVBsdWdpbk9wdHMgfHwgZGVmYXVsdF9vZmZzaWRlUGx1Z2luT3B0c1xuXG4gICAgLCB2aXNpdG9yOiA6OlxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50KHBhdGgpIDo6XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdHMua2V5d29yZF9ibG9ja3MpIDo6IHJldHVyblxuICAgICAgICAgIGlmICghbGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMuaGFzKHBhdGgucGFyZW50LnR5cGUpKSA6OiByZXR1cm5cblxuICAgICAgICAgIGxldCBrZXl3b3JkID0ga2V5d29yZF9ibG9ja19wYXJlbnRzW3BhdGgucGFyZW50LnR5cGVdXG4gICAgICAgICAgaWYgKCdpZicgPT09IGtleXdvcmQgJiYgcGF0aC5ub2RlID09PSBwYXRoLnBhcmVudC5hbHRlcm5hdGUpIDo6XG4gICAgICAgICAgICBrZXl3b3JkID0gJ2Vsc2UnIC8vIGZpeHVwIGlmL2Vsc2UgY29tYmluZWQgcGFyZW50IGNvbmRpdGlvblxuXG4gICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yIEBcbiAgICAgICAgICAgIGBLZXl3b3JkICcke2tleXdvcmR9JyBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYSBibG9jayBzdGF0ZW1lbnQgdXNpbmcgJzo6JyBvciBtYXRjaGluZyAneycgLyAnfScuIFxcbmAgK1xuICAgICAgICAgICAgYCAgICAoRnJvbSAna2V5d29yZF9ibG9ja3MnIGVuZm9yY2VtZW50IG9wdGlvbiBvZiBiYWJlbC1wbHVnaW4tb2Zmc2lkZSlgXG5cblxuT2JqZWN0LmFzc2lnbiBAIGV4cG9ydHMsXG4gIEB7fVxuICAgIGhvb2tCYWJ5bG9uLFxuICAgIHBhcnNlT2Zmc2lkZUluZGV4TWFwLFxuXG4iXX0=